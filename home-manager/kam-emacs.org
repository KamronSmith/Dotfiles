#+title: Kam's Emacs Configuration
#+author: Kamron Smith
#+language: en
#+options: ':t toc:nil author:t email:t num:t
#+startup: content
#+macro: latest-export-date (eval (format-time-string "%F %T %z"))

*Last revised and exported on {{{latest-export-date}}}*

* Goals and purpose of my Emacs configuration
:PROPERTIES:
:CUSTOM_ID: h:097832D0-F925-4E00-B4CB-A45FB67C736A
:ID:       20DC37BE-79FE-47D5-BFB7-7B43DE5A113A
:END:
The general goal is to organize everything into /projects/, which I will loosely define as more than 1 task that leads to a single outcome. Each project can have more than one file, buffer, or window associated with it. The goal of this configuration is to make managing projects, and their associated materials low effort to effortless.

Additionally, I use this configuration to remind myself of useful Emacs features that I should be using.
* Anatomy of this configuration
:PROPERTIES:
:CUSTOM_ID: h:61BD6B95-C538-4C93-8ADA-451D8594CC54
:ID:       A9B2A56A-534B-40AC-9E0A-B8A6E3438633
:END:
This configuration is split into a few parts:
- =early-init.el= :: Optimizes the Emacs startup and introduces some basic settings.
- =init.el= :: Contains basic settings, settings about native Emacs packages, and loads the later modules.
- =kam-emacs-modules= directory :: Includes all of the modules of the configuration, where one module is aimed around a specific piece of functionality.
* The =early-init= file
:PROPERTIES:
:CUSTOM_ID: h:A364AC94-F527-4F61-8BD8-74E52286AE46
:END:
** Adding GCC and LIBGCCJIT to the PATH
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "early-init.el") :mkdirp yes
(defun kam-append-env-var (var-name value)
  "Append VALUE to the beginning of the current value of env variable VAR-NAME."
  (setenv var-name
          (if (getenv var-name)
              (format "%s:%s" value (getenv var-name))
            value)))

;; (add-to-list 'exec-path "/opt/homebrew/bin/")

  ;; (let  ((gccjitpath "/opt/homebrew/Cellar/gcc/"))
  ;; (mapc
  ;;  (lambda (var-name) (kam-append-env-var var-name gccjitpath))
  ;;  '("LIBRARY_PATH" "LD_LIBRARY_PATH" "PATH")))

;; (setenv "LIBRARY_PATH" "/opt/homebrew/opt/gcc@14/lib/gcc/14:/opt/homebrew/opt/libgccjit/lib/gcc/14:/opt/homebrew/opt/gcc/lib/gcc/14/gcc/aarch64-apple-darwin24/14")
#+END_src
** Setting the garbage collection options
:PROPERTIES:
:CUSTOM_ID: h:1DDC7EBE-6854-4D88-B547-8C522E9C56EA
:END:
#+begin_src emacs-lisp :tangle (format early-init-file "%s")
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.5)

(setq load-prefer-newer t)

(add-hook 'emacs-startup-hook
          (lambda ()
            (setq gc-cons-threshold (* 1000 1000 8)
                  gc-cons-percentage 0.1)))
#+end_src
** Setting frame parameters
:PROPERTIES:
:CUSTOM_ID: h:E234E02E-5698-4338-B7E5-19592E721194
:END:
#+begin_src emacs-lisp :tangle (format early-init-file "%s")
(setq frame-resize-pixel-wise t
      frame-inhibit-implied-resize t
      default-frame-alist '((fullscreen . maximized)
                            ;;                             (background-color . "#1e1e1e")
                            (ns-appearance . dark)
                            (ns-transparent-titlebar . t))
      ring-bell-function 'ignore
      use-file-dialog nil
      inhibit-splash-screen t
      inhibit-startup-screen t
      inhibit-x-resources t)
#+end_src
** Disabling the default package manager
:PROPERTIES:
:CUSTOM_ID: h:84E1F360-CA49-471E-8E12-9CDFC062DFC8
:END:
This causes problems, so its better to disable it
#+begin_src emacs-lisp :tangle (format early-init-file "%s")
(setq package-enable-at-startup nil
      use-package-enable-imenu-support t)
#+end_src
* The =init.el= file
:PROPERTIES:
:CUSTOM_ID: h:6CA91EE7-5F41-4CA1-B9F2-4BD11386BFE7
:End:
** Putting all of the modules on the =load-path=
:PROPERTIES:
:CUSTOM_ID: h:EDED952C-4E83-4DD0-BF63-391F46DBE64E
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(mapcar
 (lambda (string)
   (add-to-list 'load-path (locate-user-emacs-file string)))
 '("lisp"))
#+end_src
** Setting up the =package manager=
:PROPERTIES:
:CUSTOM_ID: h:73796FB2-63C2-44E4-B008-8EDC6E7AB645
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
  (defvar elpaca-installer-version 0.9)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                                :ref nil
                                :files (:defaults (:exclude "extensions"))
                                :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
         (build (expand-file-name "elpaca/" elpaca-builds-directory))
         (order (cdr elpaca-order))
         (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (< emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
          (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                   ((zerop (call-process "git" nil buffer t "clone"
                                         (plist-get order :repo) repo)))
                   ((zerop (call-process "git" nil buffer t "checkout"
                                         (or (plist-get order :ref) "--"))))
                   (emacs (concat invocation-directory invocation-name))
                   ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                         "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                   ((require 'elpaca))
                   ((elpaca-generate-autoloads "elpaca" repo)))
              (progn (message "%s" (buffer-string)) (kill-buffer buffer))
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))
  ;;; (elpaca-wait)

  (setq use-package-always-ensure t)

  (elpaca elpaca-use-package
    (elpaca-use-package-mode))
  
  (setq font-log nil
        package-install-upgrade-built-in t
        package-selected-packages '(jsonrpc consult org-roam))
#+end_src
** Adjusting native compilation
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(when (native-comp-available-p)
  (setq native-comp-async-report-warnings-errors 'silent
        native-comp-prune-cache t))
#+end_src
** Disabling the annoying bars and screens
:PROPERTIES:
:CUSTOM_ID: h:E482268C-9479-4F80-84A3-BBE7E385F567
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(menu-bar-mode -1)
(tab-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(blink-cursor-mode -1)
(setq inhibit-splash-screen t)
#+end_src
** The =init.el= section for increasing the =max-lisp-eval-depth=
:PROPERTIES:
:CUSTOM_ID: h:218C6F03-9D61-4256-8050-3001EB263980
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(setq max-lisp-eval-depth 3200)
#+end_src
** Setting the =backup configurations=
:PROPERTIES:
:CUSTOM_ID: h:2A2501AB-D674-4B03-A259-7D62D815E6B8
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(setq make-backup-files nil
      backup-inhibited t
      create-lockfiles nil)

(setq auto-save-file-name-transforms
      `((".*" , (concat user-emacs-directory "auto-save-list/") t)))

(setq kill-buffer-delete-auto-save-files t)
#+end_src
** Disabling annoying confirmation messages
:PROPERTIES:
:CUSTOM_ID: h:E8861DAD-4CA5-459F-8E4D-22CB4645568C
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(setq confirm-kill-emacs nil)
(setq confirm-kill-processes nil)
(setq confirm-non-existent-file-or-buffer nil)
(setq use-short-answers t)
(setq kill-buffer-query-functions
      (remq 'process-kill-buffer-query-function
            kill-buffer-query-functions))
(setq initial-scratch-message "")
#+end_src
** Using the system trash
:PROPERTIES:
:CUSTOM_ID: h:48570B02-C51A-46B2-B070-5F24F61B9E21
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(setq delete-by-moving-to-trash t)
#+end_src
** The =init.el= section to disable the custom file
:PROPERTIES:
:CUSTOM_ID: h:05439142-3517-48DE-B997-F73434A7B79B
:END:
I don't want any lisp called in my Emacs configuration that I didn't write myself.

I disable the custom file by making it disposable.
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(setq custom-file (make-temp-file "emacs-custom-"))
#+end_src
** The =init.el= section to set the initial scratch buffer's major mode to Emacs-lisp mode
:PROPERTIES:
:CUSTOM_ID: h:061CDF86-0F3F-49F1-A86E-92D0D07A238E
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(setq initial-major-mode 'emacs-lisp-mode)
#+end_src
** =Default settings=
:PROPERTIES:
:CUSTOM_ID: h:A667A06D-EDCE-41AF-A7FE-94775942BB26
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(setq-default line-spacing 0.4
              c-basic-offset 4
              c-default-style "linux"
              fill-column 80
              indent-tabs-mode nil
              next-screen-context-lines 20
              cursor-type 'bar
              tab-width 4
              ;; scroll-margin 99999
              cursor-in-non-selected-windows nil)
#+end_src
** Mac specific settings
:PROPERTIES:
:CUSTOM_ID: h:67DE7323-31FA-459F-82E3-7FEC46D6D498
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(when (eq system-type 'darwin)
  (setq mac-option-key-is-meta nil
        mac-command-key-is-meta t
        mac-control-modifier 'control
        mac-command-modifier 'meta
        mac-option-modifier 'hyper))

(add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
(add-to-list 'default-frame-alist '(ns-appearance . dark))
#+end_src
** Linux specific settings
:PROPERTIES:
:CUSTOM_ID: h:057410F5-6704-4B86-86F3-3F800DF327EB
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
 (when (eq system-type 'gnu/linux)
   (setq x-super-keysym 'meta
         x-meta-keysym 'alt))
#+end_src
** =Completions=
:PROPERTIES:
:CUSTOM_ID: h:3A79B6A1-2534-4FF6-94BE-D8B00BBD835F
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(setq enable-recursive-minibuffers t
      completion-cycle-threshold 1
      completions-detailed t
      tab-always-indent 'complete
      completion-styles '(basic initials substring)
      completion-auto-help 'lazy
      completions-max-height 20
      completions-format 'one-column
      completions-group t
      completion-auto-select 'second-tab
      completion-ignore-case t
      read-file-name-completion-ignore-case t)
#+end_src
** =Imenu=
:PROPERTIES:
:CUSTOM_ID: h:0360CC8E-0EA6-40C0-B88C-FC0C38B3986D
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(use-package imenu
  :ensure nil
  :bind
  (([remap imenu] . consult-imenu))
  :config
  (setq org-imenu-depth 4))
#+end_src
**  =help-mode=
:PROPERTIES:
:CUSTOM_ID: h:D661E16E-B075-468A-AEEE-A68D3F817881
:END:
**  =occur=
:PROPERTIES:
:CUSTOM_ID: h:82B82CF0-FEF5-4431-93A3-C08576891A90
:END:
Occur is a command that shows all lines in a buffer that match a user given regex.
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
;;(use-package occur
;; :ensure nil)
(setq list-matching-lines-default-context-lines 2)

(defun kam-get-buffers-matching-mode (mode)
  "Returns a list of the buffers where their major-mode is equal to MODE."
  (let ((buffer-mode-matches '()))
    (dolist (buf (buffer-list))
      (with-current-buffer buf
        (when (eq mode major-mode)
          (push buf buffer-mode-matches))))
    buffer-mode-matches))

(defun kam-multi-occur-in-this-mode ()
  "Show all lines matching REGEXP in buffers with the current buffer's major-mode."
  (interactive)
  (multi-occur
   (kam-get-buffers-matching-mode major-mode)
   (car (occur-read-primary-args))))
#+end_src
** Minibuffer
:PROPERTIES:
:CUSTOM_ID: h:93BE1CDF-9EC8-4408-85AE-1C4CB8BE79C1
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(use-package emacs
  :ensure nil
  :custom
  (read-extended-command-predicate #'command-completion-default-include-p)
  :init
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string
                   "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                   crm-separator)
                  (car args))
          (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))

  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
  
  (setq resize-mini-windows 'grow-only
        resize-mini-frames 'grow-only))
#+end_src
** =undo=
:PROPERTIES:
:CUSTOM_ID: h:FC224E32-F90A-4CDA-859B-967AA06176C5
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(defvar undo-repeat-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "u") 'undo)
    map))

(dolist (cmd '(undo))
  (put cmd 'repeat-map 'undo-repeat-map))
#+end_src
** =re-builder=
:PROPERTIES:
:CUSTOM_ID: h:11D0AF31-C303-4331-807A-CE55374A6836
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(use-package re-builder
  :ensure nil
  :bind
  (:map reb-mode-map
        ("RET" . #'kam-re-builder-replace-regexp)
        ("<escape>" . #'reb-quit)
        :map reb-lisp-mode-map
        ("RET" . #'kam-re-builder-replace-regexp)
        ("<esc>" . #'reb-quit))
  :config
  
  (defvar kam-re-builder-positions nil
    "Store point and region bounds before calling re-builder")
  
  (advice-add 're-builder
              :before
              (defun kam-re-builder-save-state (&rest _)
                "Save into `kam-rebuilder-positions' the point and the region before calling `re-builder'."
                (setq kam-re-builder-positions
                      (cons (point)
                            (when (region-active-p)
                              (list (region-beginning)
                                    (region-end)))))))
  
  (defun kam-re-builder-replace-regexp (&optional delimited)
    "Run `query-replace-regexp' with the contents of 're-builder'.
With non-nil optional argument DELIMITED, only replace matches surrounded by actual boundaries."
    (interactive "P")
    (reb-update-regexp)
    (let* ((re (reb-target-value 'reb-regexp))
           (replacement (query-replace-read-to
                         re
                         (concat "Query replace"
                                 (if current-prefix-arg
                                     (if (eq current-prefix-arg '-) " backward" " word")
                                   "")
                                 " regexp"
                                 (if (with-selected-window reb-target-window
                                       (region-active-p)) " in region" ""))
                         t))
           (pnt (car kam-re-builder-positions))
           (beg (cadr kam-re-builder-positions))
           (end (caddr kam-re-builder-positions)))
      (with-selected-window reb-target-window
        (goto-char pnt)
        (setq kam-re-builder-positions nil)
        (reb-quit)
        (query-replace-regexp re replacement delimited beg end)))))
#+end_src
** =Tramp=
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(use-package tramp
  :ensure nil
  :config
  (setq tramp-encoding-shell (executable-find "sh")
        sh-shell-file (executable-find "bash")
        shell-file-name (executable-find "bash"))
  
  (add-to-list 'tramp-connection-properties
               (list (regexp-quote "/sudo::")
                     "login-program" (executable-find "env")))
  
  (add-to-list 'tramp-connection-properties
               (list (regexp-quote "/sudo::")
                     "remote-shell" (executable-find "env"))))
#+end_src
** =find-file=
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(defun kam-auto-create-missing-dirs ()
  (let ((target-dir (file-name-directory buffer-file-name)))
    (unless (file-exists-p target-dir)
      (make-directory target-dir t))))

(add-to-list 'find-file-not-found-functions #'kam-auto-create-missing-dirs)
#+end_src
** =recentf-mode=
:PROPERTIES:
:CUSTOM_ID: h:C206B5BA-3AC7-4346-A380-2C0A0D832D0C
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(use-package recentf
  :ensure nil
  :hook (after-init . recentf-mode)
  :config
  (setq recentf-max-saved-items 50))
#+end_src
** =completion-preview-mode=
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(global-completion-preview-mode 1)
#+end_src
** =scrolling= settings
:PROPERTIES:
:CUSTOM_ID: h:2D6B25C1-7F83-4AF9-B9D0-8B6382EE8ADD
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(pixel-scroll-precision-mode nil)
(setq pixel-scroll-precision-interpolate-mice nil)
;; (setq scroll-conservatively 10
;;       maximum-scroll-margin 0.5
;;       scroll-preserve-screen-position t)

(use-package ultra-scroll
  :ensure (ultra-scroll :host github :repo "jdtsmith/ultra-scroll")
  :bind
  (("<wheel-up>" . ultra-scroll-up)
   ("<wheel-down>" . ultra-scroll-down))
  :init
  (setq-default scroll-conservatively 101
        scroll-margin 0)
  :config
  (ultra-scroll-mode 1))
#+end_src
** =repeat-mode=
:PROPERTIES:
:CUSTOM_ID: h:1DADCF8B-7411-4908-8EB9-ED2CD0D4DA34
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(use-package repeat
  :ensure nil
  :hook (after-init . repeat-mode)
  :config
  (setq repeat-on-final-keystroke t
        repeat-exit-timeout 5
        repeat-exit-key "<escape>"
        repeat-keep-prefix nil
        repeat-check-key t
        repeat-echo-function 'ignore
        set-mark-command-repeat-pop t))

(defun kam-make-repeat-map (keymap)
  "Add `repeat-mode' support to KEYMAP."
  (map-keymap
   (lambda (_key cmd)
     (when (symbolp cmd)
       (put cmd 'repeat-map keymap)))
   (symbol-value keymap)))
#+end_src
** =keyfreq=
:PROPERTIES:
:CUSTOM_ID: h:9F15EF8E-6BAA-4E63-85AA-E35EC09ECFD8
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(use-package keyfreq
:ensure t
:config
(keyfreq-mode))
#+end_src
** =bookmarks=
:PROPERTIES:
:CUSTOM_ID: h:25E3DCCC-A2B4-4C3D-8DB6-CD2D26BE360D
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(use-package bookmark
  :ensure nil
  :commands (bookmark-set bookmark-jump bookmark-bmenu-list)
  :hook (bookmark-bmenu-mode . hl-line-mode)
  :bind
  ("C-c t" . consult-bookmark)
  :config
  (setq bookmark-use-annotations nil
        bookmark-automatically-show-annotations nil
        bookmark-fringe-mark nil
        bookmark-save-flag 1))
#+end_src
** =registers=
:PROPERTIES:
:CUSTOM_ID: h:72DA1A59-8097-461A-A9FA-78C315121F25
:END:
Registers in Emacs are similar to the ones found in Vim.

Additional code is added to save the contents of registers after Emacs closes, so they are essentially permanent until the user deletes them.
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(use-package register
  :ensure nil
  :defer t
  :config
  (setq register-preview-delay 0.8
        register-preview-function #'register-preview-default)

  (with-eval-after-load 'savehist
    (add-to-list 'savehist-additional-variables 'register-alist)))
#+end_src
** =abbrev-mode=
:PROPERTIES:
:CUSTOM_ID: h:5DAC9775-CDE6-4199-A338-AAA2E952DA94
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(use-package abbrev
  :ensure nil
  :config
  (setq-default abbrev-mode t))
#+end_src
** =keyboard macros=
:PROPERTIES:
:CUSTOM_ID: h:5F327C1F-2868-4C45-9533-8B95E54AA4FC
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(use-package kmacro
  :ensure nil
  :bind
  (:map kmacro-keymap
        ("I" . #'kmacro-insert-macro))
  :config
  (defalias 'kmacro-insert-macro 'insert-keyboard-macro))
#+end_src
** =auto-revert-mode=
:PROPERTIES:
:CUSTOM_ID: h:2054818A-2C0D-45A9-A01D-B9F261921286
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(use-package autorevert
  :ensure nil
  :hook (after-init . global-auto-revert-mode)
  :config
  (setq auto-revert-verbose nil
        global-auto-revert-non-file-buffers t))
#+end_src
** =delete-section-mode=
:PROPERTIES:
:CUSTOM_ID: h:E6B53794-EFA4-4E55-9BD7-0E75B8DC956D
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(use-package delsel
  :ensure nil
  :hook (after-init . delete-selection-mode))
#+end_src
** =savehist-mode=
:PROPERTIES:
:CUSTOM_ID: h:31033B87-D998-4952-A1E9-3F12073CBB44
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(savehist-mode)

(setq history-length 50)
#+end_src
** =tooltips=
:PROPERTIES:
:CUSTOM_ID: h:C01A39EB-7EA5-4FF0-9B13-AAE577F85F79
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(tooltip-mode -1)
(setq x-gtk-use-system-tooltips nil
      tooltip-reuse-hidden-frame t
      tooltip-use-echo-area t)
#+end_src
** =manpages=
:PROPERTIES:
:CUSTOM_ID: h:42C5BC72-EF43-4A8C-98A5-D68E3B7D7CAA
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(use-package man
  :ensure nil
  ;;    :commands (man)
  :config
  (setq Man-notify-method 'pushy))
#+end_src
** =proced=
:PROPERTIES:
:CUSTOM_ID: h:1CF5B0BC-B163-4BC8-B8B9-221C79C09475
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(use-package proced
  :ensure nil
  ;;   :commands (proced)
  ;;    :hook (proced-mode . #'kam-proced-settings)
  :config
  (setq proced-auto-update-flag 'visible
        proced-enable-color-flag t
        proced-auto-update-interval 1
        proced-descend t
        proced-filter 'user)
  
  (defun kam-proced-settings ()
    (proced-toggle-auto-update)))
#+end_src
** Cross program usage
:PROPERTIES:
:CUSTOM_ID: h:3FC7668F-D348-4F05-BD4B-D463E52641B1
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(setq save-interprogram-paste-before-kill t
      mouse-drag-and-drop-region-cross-program t
      mouse-drag-and-drop-region-scroll-margin t)
#+end_src
** =global-so-long-mode=
:PROPERTIES:
:CUSTOM_ID: h:1AD00154-0759-44D0-ADCB-0110D88C685B
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(global-so-long-mode 1)
#+end_src
** Clipboards
:PROPERTIES:
:CUSTOM_ID: h:A21013CB-A2DA-4C20-990A-EF0E9B96DB74
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(setq x-select-enable-clipboard t
      x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+end_src
** Daemon
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(if (daemonp)
    (add-hook 'after-make-frame-functions
              (lambda (frame)
                (with-selected-frame frame
                  (kam-set-font-faces)
                  (kam-set-custom-faces)
                  (load-theme 'modus-vivendi :no-confirm))))
  (load-theme 'modus-vivendi :no-confirm)
  (add-hook 'after-init-hook #'kam-set-custom-faces)
  (add-hook 'after-init-hook #'kam-set-font-faces))
#+end_src
** The call to load all of the modules
:PROPERTIES:
:CUSTOM_ID: h:FB459034-485D-4BB9-8CF1-030E0C45EA0A
:END:
#+begin_src emacs-lisp :tangle (format user-init-file "%s")
(mapc (lambda (name)
        (require (intern (file-name-sans-extension name))))
      (directory-files (concat user-emacs-directory "lisp/") nil ".+\\.elc?$"))
#+end_src
* Modules
:PROPERTIES:
:CUSTOM_ID: h:24489BD3-FFC5-4686-B40D-D5311BCB4DF8
:END:
** Purpose
:PROPERTIES:
:CUSTOM_ID: h:832C5F14-F1AC-43B9-8E52-9DB55B4A3874
:END:
This part of the config is dedicated to writing the underlying functions that make the commands listed in the modules work.
** The =Essentials= module
:PROPERTIES:
:CUSTOM_ID: h:27D008C9-A255-450C-8014-FD21D2FEB67A
:END:
*** Purpose
:PROPERTIES:
:CUSTOM_ID: h:CC830B7C-39CE-4BD6-80CF-1A0995CE21B1
:END:
The purpose of the essentials module is to transform Emacs UI from ancient and outdated to new and sophisticated. I do this using a number of newer packages, the most important being =Consult=, =Vertico=, and =Avy=.
*** The =Essentials= section that sets up =Marginalia=
:PROPERTIES:
:CUSTOM_ID: h:D3D58FF4-7BE7-41EF-ACB2-6F63FF339CB2
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-essentials.el")
(use-package marginalia
    :ensure t
    :config
    (marginalia-mode))
#+end_src
*** The =Essentials= section that sets up =Orderless=
:PROPERTIES:
:CUSTOM_ID: h:86EC6A78-B549-417B-B810-5D2B7C2937C8
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-essentials.el")
(use-package orderless
  :ensure t
  :config

  (defun kam-orderless--consult-suffix ()
    "Regexp which matches the end of string with Consult tofu support."
    (if (and (boundp 'consult--tofu-char) (boundp 'consult--tofu-range))
        (format "[%c-%c]*$"
                consult--tofu-char
                (+ consult--tofu-char consult--tofu-range -1))
      "$"))
  
  (defun kam-orderless-consult-dispatch (word _index _total)
    (cond
     ((string-suffix-p "$" word)
      `(orderless-regexp . ,(concat (substring word 0 -1) (kam-orderless--consult-suffix))))
     ((and (or minibuffer-completing-file-name
               (derived-mode-p 'eshell-mode))
           (string-match-p "\\`\\.." word))
      `(orderless-regexp . ,(concat "\\." (substring word 1) (kam-orderless--consult-suffix))))))

  (orderless-define-completion-style kam-orderless-with-initialism
    (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp)))
  
  (setq completion-styles '(orderless basic)
        completion-category-overrides '((file (styles partial-completion))
                                        (command (styles kam-orderless-with-initialism))
                                        (variable (styles kam-orderless-with-initialism))
                                        (symbol (styles kam-orderless-with-initialism)))
        orderless-component-separator #'orderless-escapable-split-on-space
        orderless-style-dispatchers (list #'kam-orderless-consult-dispatch
                                          #'orderless-affix-dispatch)))


(setq read-buffer-completion-ignore-case t)
#+end_src
*** The =Essentials= section that sets up =Vertico=
:PROPERTIES:
:CUSTOM_ID: h:24EE7C95-8437-4A01-9186-333158BBC629
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-essentials.el")
  (use-package vertico
    :ensure t
    :init
    (vertico-mode)
    :bind
    (:map vertico-map
          ("<escape>" . #'kam-keyboard-quit-dwim)
          ("C-," . vertico-scroll-up)
          ("M-," . vertico-scroll-down)
          ("M-RET" . vertico-exit-input)
          ("<up>" . nil)
          ("<down>" . nil)
          ("C-<return>" . #'minibuffer-force-complete-and-exit)
          ("<f6>" . vertico-quick-exit)
          ("RET" . vertico-directory-enter)
          ("<backspace>" . vertico-directory-delete-char)
          ("C-<backspace>" . vertico-directory-delete-word)
          ("C-g" . nil))
    :config
    (setq vertico-resize 'grow-only
          vertico-cycle t)

    (defun kam-vertico--match-directory (str)
      "Match directory delimiter in STR."
      (string-suffix-p "/" str))

    (defun kam-vertico--sort-directories-first (files)
      "Sort directories before files."
      (setq files (vertico-sort-alpha files))
      (nconc (seq-filter #'kam-vertico--match-directory files)
             (seq-remove #'kam-vertico--match-directory files))))

  (use-package vertico-quick
    :after vertico
    :ensure nil
    :config
    (setq vertico-quick1 "dnreta"
          vertico-quick2 "columq"))

  (use-package vertico-directory
    :after vertico
    :ensure nil
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))

  (use-package vertico-multiform
    :ensure nil
    :after vertico
    :bind
    (:map vertico-multiform-map
          ("<escape>" . #'kam-keyboard-quit-dwim)
          ("<next>" . vertico-scroll-up)
          ("<prior>" . vertico-scroll-down)
          ("<up>" . nil)
          ("<down>" . nil)
          ("C-<return>" . #'minibuffer-force-complete-and-exit)
          ("M-<return>" . vertico-exit-input)
          ("<f6>" . vertico-quick-exit)
          ("C-<f6>" . vertico-quick-insert)
          ("RET" . vertico-directory-enter)
          ("<backspace>" . vertico-directory-delete-char)
          ("C-<backspace>" . vertico-directory-delete-word)
          ("C-g" . nil))
    :config
    (setq vertico-multiform-categories
          '((embark-keybinding grid (vertico-sort-function . vertico-sort-alpha))
            (file (vertico-sort-function . vertico-sort-history-length-alpha)
                  (vertico-count . 10)
                  (vertico-resize . t))
            (imenu (mouse))
            (jinx grid (vertico-grid-annotate . 20))
            (buffer (vertico-sort-function . nil))))
    (setq vertico-multiform-commands
          '((consult-ripgrep buffer)
            (consult-line posframe
                          (vertico-posframe-poshandler . posframe-poshandler-window-center)
                          (vertico-posframe-border-width . 2))
            (kam-search-notes buffer)
            (consult-imenu buffer indexed)
            (consult-buffer (vertico-sort-function . vertico-sort-history-alpha))
            (org-roam-node-find (vertico-sort-function . nil))
            (jinx-correct-nearest grid (vertico-grid-annotate . 20))))
    (vertico-multiform-mode))

  (use-package vertico-reverse
    :ensure nil
    :after vertico)

  (use-package vertico-posframe
    :ensure
    (:host github
           :repo "tumashu/vertico-posframe")
    :after vertico)
#+end_src
*** The =Essentials= section that sets up =Embark=
:PROPERTIES:
:CUSTOM_ID: h:A1826CA8-AA3B-4A2C-9B2F-F721CB6DE4FE
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-essentials.el")
(use-package embark
  :bind
  ([remap describe-bindings] . embark-bindings)
  ("<f1>" . #'embark-act)
  ("C-<f1>" . #'embark-dwim)
  :init
  (setq prefix-help-command #'embark-prefix-help-command)
  (setq embark-prompter #'embark-keymap-prompter)
  (setq embark-indicators '(embark-highlight-indicator
                            embark-isearch-highlight-indicator))
  :ensure t
  :config
  (keymap-set embark-expression-map ";" #'kam-comment-dwim)
  (keymap-set embark-general-map "SPC" 'embark-cycle))

(use-package embark-consult
  :ensure t
  :hook (embark-collect-mode . consult-preview-at-point-mode))
#+end_src
*** The =Essentials= section that sets up =Consult=
:PROPERTIES:
:CUSTOM_ID: h:FC68FE2E-E1DF-4206-AB94-A89F62D9C09F
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-essentials.el")
(use-package consult
  :ensure t
  :init
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format
        xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  (advice-add #'register-preview :override #'consult-register-window)
  :bind
  (:map global-map
        (([remap Info-search] . consult-info)
         ("C-x b" . consult-buffer)
         ("C-x C-r" . consult-recent-file)
         ("C-M-x" . consult-mode-command)
         ("C-M-;" . consult-complex-command)
         ("M-y" . consult-yank-pop)
         ("C-j" . consult-register-store)
         ("M-j" . consult-register-load)
         ("C-x C-r" . consult-recent-file)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)
         ("M-s e" . consult-isearch-history)
         ("M-s l" . consult-line)
         :map minibuffer-local-map
         ("M-s" . consult-history)
         ("M-r" . consult-history)))
  :config
  (setq consult-narrow-key ">")
  (add-to-list 'consult-preview-allowed-hooks 'global-org-modern-mode)
  (add-to-list 'consult-preview-allowed-hooks 'olivetti-mode)  
  (add-to-list 'consult-preview-allowed-hooks 'variable-pitch-mode)

  (dolist (src consult-buffer-sources)
    (unless (eq src 'consult--source-buffer)
      (set src (plist-put (symbol-value src) :hidden t)))))

(use-package consult-dir
  :ensure t
  :bind
  (:map vertico-map
        ("C-r C-d" . consult-dir)
        ("C-r C-j" . consult-dir-jump-file))
  :config
  (setq consult-dir-shadow-file-names nil)

  ;; (defun kam-recentf-top-num (num)
  ;;   "Return the most recent NUM of recently visited files."
  ;;   (take num recentf-list))

  ;; (defvar kam-consult-dir--source-recentf-top-15
  ;;   `(:name "Recent Files"
  ;;           :narrow ?u
  ;;           :category file
  ;;           :face consult-file
  ;;           :history file-name-history
  ;;           :enabled ,(lambda () recentf-mode)
  ;;           :items ,(kam-recentf-top-num 15)))

  ;; (add-to-list 'consult-dir-sources 'kam-consult-dir--source-recentf-top-15 t)
  )
#+end_src
*** The =Essentials= section that sets up =Corfu=
:PROPERTIES:
:CUSTOM_ID: h:17B80903-0C9D-45F7-931F-212D328F1FDA
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-essentials.el")
(use-package corfu
  :ensure t
  :init
  (global-corfu-mode 1)
  :custom
  (corfu-separator ?\s)
  (corfu-preview-current t)
  (corfu-cycle t)
  :bind
  (:map corfu-map
        ("<return>" . #'corfu-insert)
        ("SPC" . #'corfu-insert-separator)
        ("C-," . corfu-scroll-up)
        ("M-," . corfu-scroll-down))
  :config
  (setq corfu-preview-current nil
        corfu-min-width 20)


  (with-eval-after-load 'save-hist
    (corfu-history-mode 1)
    (add-to-list 'save-hist-additional-variables 'corfu-history)))

(use-package corfu-quick
  :ensure nil
  :after (corfu)
  :bind
  (:map corfu-map
        ("<f6>" . corfu-quick-complete))
  :config
  (setq corfu-quick1 "dnreta"
        corfu-quick2 "dnreta"))

(use-package corfu-popupinfo
  :ensure nil
  :after (corfu)
  :config
  (corfu-popupinfo-mode))

(use-package nerd-icons-corfu
  :ensure t
  :after (corfu)
  :config
  (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src
*** The =Essentials= section that sets up =Cape=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-essentials.el")
(use-package cape
  :ensure t
  :bind ("C-c p" . cape-prefix-map)
  :init
  (add-hook 'completion-at-point-functions #'cape-dabbrev)
  (add-hook 'completion-at-point-functions #'cape-file)
  (add-hook 'completion-at-point-functions #'cape-keyword)
  (add-hook 'completion-at-point-functions #'cape-elisp-block)
  ;; (add-hook 'completion-at-point-functions #'cape-dict)
  )
#+end_src
*** The =Essentials= section that sets up =Avy=
:PROPERTIES:
:CUSTOM_ID: h:9BF7E490-FDB9-444B-BBE5-1B07E6624337
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-essentials.el")
(use-package avy
  :ensure t
  :bind
  ("<f6>" . avy-goto-char-timer)
  :config
  (setq avy-keys '(?d ?n ?r ?e ?t ?a ?s ?i)
        avy-style 'at-full
        avy-timeout-seconds 1.0)
  
  (defun kam-avy-action-embark (pt)
    (unwind-protect
        (save-excursion 
          (goto-char pt)
          (embark-act))
      (select-window
       (cdr (ring-ref avy-ring 0))))
    t)

  (defun kam-avy-action-expand-region (pt)
    (unwind-protect
        (save-excursion
          (goto-char pt)
          (er/expand-region))
      (select-window
       (cdr
        (ring-ref avy-ring 0))))
    t)

  (defun kam-avy-action-kam-cut (pt)
    (unwind-protect
        (save-excursion
          (goto-char pt)
          (kam-cut-dwim))
      (select-window
       (cdr
        (ring-ref avy-ring 0))))
    t)

  (defun kam-avy-action-mark-to-char (pt)
    (activate-mark)
    (goto-char pt))

  (defun kam-avy-action-org-store-link (pt)
    (unwind-protect
        (save-excursion
          (goto-char pt)
          (org-store-link nil t))
      (select-window
       (cdr
        (ring-ref avy-ring 0))))
    t)

  (defun kam-avy-action-org-refile (pt)
    (unwind-protect
        (save-excursion
          (goto-char pt)
          (kam-org-refile-to-current-file-heading))
      (select-window
       (cdr
        (ring-ref avy-ring 0))))
    t)

  (defun kam-avy-action-kill-inner-sexp (pt)
    (unwind-protect
        (progn
          (goto-char pt)
          (kam-kill-inner-sexp))
      (select-window
       (cdr
        (ring-ref avy-ring 0))))
    t)

  (defun kam-avy-zap-to-char ()
    "test"
    (interactive)
    (avy-with avy-goto-char-timer
      (avy-action-zap-to-char pt)))

  (setf (alist-get ?. avy-dispatch-alist) 'kam-avy-action-embark)
  (setf (alist-get ?w avy-dispatch-alist) 'kam-avy-action-kam-cut)
  (setf (alist-get ?o avy-dispatch-alist) 'kam-avy-action-org-refile)
  (setf (alist-get ?v avy-dispatch-alist) 'kam-avy-action-mark-to-char)
  (setf (alist-get ?l avy-dispatch-alist) 'kam-avy-action-org-store-link)
  (setf (alist-get ?q avy-dispatch-alist) 'kam-avy-action-kill-inner-sexp))
#+end_src
*** The =Essentials= section that contains custom lisp
:PROPERTIES:
:CUSTOM_ID: h:3227C69B-A699-4F5E-B1C5-182A92367C89
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-essentials.el")
(defun kam-keyboard-quit-dwim ()
  (interactive)
  (cond
   ((region-active-p)
    (keyboard-quit))
   ((derived-mode-p 'completion-list-mode)
    (delete-completion-window))
   ((> (minibuffer-depth) 0)
    (abort-recursive-edit))
   (t
    (keyboard-quit))))

(defun kam-kill-current-buffer (&optional arg)
  "Kill the current buffer, no prompts.
With optional prefix ARG (\\[universal-argument]), delete the buffer's window as well."
  (interactive "P")
  (let ((kill-buffer-query-functions nil))
    (if (or (null (window-prev-buffers))
            (and (not (one-window-p))))
        (kill-buffer-and-window)
      (kill-buffer))))
#+end_src
*** The call to provide =Essentials=
:PROPERTIES:
:CUSTOM_ID: h:5B6745C0-21F1-44C2-9E6F-A8D86CE51480
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-essentials.el")
(provide 'kam-essentials)
#+end_src
** The =Naved= module
:PROPERTIES:
:CUSTOM_ID: h:04E42333-CAB3-4B71-A869-EBA2666DCA82
:END:
The =Naved= /"Navigation & Editing"/ module is concerned with the navigation and editing of files.
***  =Isearch=
:PROPERTIES:
:CUSTOM_ID: h:F12F3EA5-DE72-4169-A6F2-397F2F7F961C
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(use-package isearch
  :ensure nil
  :bind
  (:map isearch-mode-map
        ("<f6>" . avy-isearch))
  :config
  (setq isearch-lazy-count t
        isearch-lazy-count-prefix-format "(%s/%s)"
        isearch-lazy-count-suffix-format nil
        isearch-repeat-on-direction-change t
        search-whitespace-regexp ".*?"))
#+end_src
*** The =Naved= section that sets up =Harpoon=
:PROPERTIES:
:CUSTOM_ID: h:72BCFB72-E439-478C-B258-1B7BB7419E48
:END:
Harpoon is intended to be used alongside the =Project= module, where =Project= will manage the projects and associated buffers, and =Harpoon= will allow me to quickly navigate between files.
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
;; (use-package harpoon
;;   :ensure t
;;   :bind
;;    (("M-1" . harpoon-toggle-quick-menu)
;;    ("M-2" . harpoon-go-to-1)
;;    ("M-3" . harpoon-go-to-2)
;;    ("M-4" . harpoon-go-to-3)
;;    ("M-5" . harpoon-go-to-4)
;;    ("M-0" . harpoon-add-file)
;;    ("<f11>" . harpoon-add-file))
;;   :config
;;   (setq harpoon-project-package 'projectile))
#+end_src
*** The =Naved= section that sets up =Yasnippet=  
:PROPERTIES:
:CUSTOM_ID: h:480B43C6-6F2B-4BD1-8091-427C2D0F3EDA
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(use-package yasnippet
  :ensure t)
#+end_src
*** The =Naved= section that sets up =Smartparens= 
:PROPERTIES:
:CUSTOM_ID: h:CE7AEBF5-A785-4619-B49A-F50D8A62748E
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(use-package smartparens
  :ensure t)
#+end_src
*** The =Naved= section that sets up =Move-text=
:PROPERTIES:
:CUSTOM_ID: h:33AEDDD3-F155-4D7B-A6B5-F98E4D29AE32
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(use-package move-text
  :bind
  (("H-<up>" . move-text-up)
   ("H-<down>" . move-text-down))
  :ensure t)

;; indents the region properly after moving the text
(defun kam-indent-region-advice (&rest ignored)
  (let ((deactivate deactivate-mark))
    (if (region-active-p)
        (indent-region (region-beginning) (region-end))
      (indent-region (line-beginning-position) (line-end-position)))
    (setq deactivate-mark deactivate)))

(advice-add 'move-text-up :after 'kam-indent-region-advice)
(advice-add 'move-text-down :after 'kam-indent-region-advice)
#+end_src
*** The =Naved= section that sets up =Wgrep=
:PROPERTIES:
:CUSTOM_ID: h:D7ED13ED-B551-484C-8ABD-7C20A2F4C774
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(use-package wgrep
  :ensure t)
#+end_src
*** The =Naved= section that sets up =Link-hint=
:PROPERTIES:
:CUSTOM_ID: h:1165FB72-9BDE-4291-94C5-935F6AFA621B
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(use-package link-hint
  :ensure t
  :bind
  ("C-<f6>" . link-hint-open-link)) 
#+end_src
*** The =Naved= section that sets up =hippie-expand=
:PROPERTIES:
:CUSTOM_ID: h:A5C2FE9A-2249-4A5E-A05E-FBF32C7D878F
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(use-package hippie-expand
  :ensure nil
  :bind
  ([remap dabbrev-expand] . hippie-expand))
#+end_src
*** The =Naved= section about =show-paren-mode=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(use-package paren
  :ensure nil
  :config
  (setq show-paren-context-when-offscreen 'child-frame
        show-paren-delay .75))
#+end_src
*** The =Naved= section about =visible-mark-mode=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
;; (use-package visible-mark
;;   :ensure t
;;   :config
;;   (global-visible-mark-mode))
#+end_src
*** The =Naved= section about =subword-mode=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(global-subword-mode)
#+end_src
*** The =Naved= section about spell checking
:PROPERTIES:
:CUSTOM_ID: h:B1C7416B-C4FB-4CB7-99CB-6C925F5667AF
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(use-package ispell
  :ensure nil
  :config
  (setq ispell-program-name "aspell"
        ispell-dictionary "en_US"))

;; (use-package jinx
;;  :ensure t
;;  :hook (emacs-startup . global-jinx-mode)
;; :bind
;;  (("M-$" . jinx-correct-word)
;;   ("C-$" . jinx-correct-nearest))
;;  :config
;;  (setq jinx--select-keys ""))
#+end_src
*** The =Naved= section about =display-line-numbers-mode=
:PROPERTIES:
:CUSTOM_ID: h:504347E5-339C-4586-81FB-99D203C80BF1
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(setq display-line-numbers-type 'relative)
#+end_src
*** The =Naved= section about =electric-mode=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(use-package electric
  :ensure nil
  :hook ((prog-mode . electric-indent-local-mode)
         (org-mode . electric-indent-local-mode))
  :config
  (electric-pair-mode 1)
  (electric-quote-mode -1)
  (electric-indent-mode))
#+end_src
*** The =Naved= section about =dumb-jump=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
;; (use-package dumb-jump
;;   :ensure t
;;   :config
;;   (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+end_src
*** The =Naved= section about \\[next-line] inserting newlines
:PROPERTIES:
:CUSTOM_ID: h:E1531A98-B669-47AA-BF55-3FB711898721
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(setq next-line-add-newlines t)
#+end_src
*** The =Naved= section for moving lines visually
:PROPERTIES:
:CUSTOM_ID: h:351C9E33-AC55-47EA-9464-A30C5AD41565
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(setq line-move-visual t)
#+end_src
*** The =Naved= section about how many spaces should end a sentence
:PROPERTIES:
:CUSTOM_ID: h:F02C470B-A85C-47EC-82F9-0DD343D38E12
:END:
As god intended.
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(setq sentence-end-double-space nil)
#+end_src
*** The =Naved= section about killing not saving duplicates
:PROPERTIES:
:CUSTOM_ID: h:2F3308B3-AB74-4561-A73C-F9AF284162D7
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(setq kill-do-not-save-duplicates t)
#+end_src
*** The =Naved= section that contains custom lisp
:PROPERTIES:
:CUSTOM_ID: h:F53E6ABC-575D-4B03-85C6-AE54C84FA3F5
:END:
**** The =Naved= section that defines the mark commands
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(defun kam--mark (bounds)
  "Mark between BOUNDS as a cons cell of beginning and end positions."
  (push-mark (car bounds))
  (goto-char (cdr bounds))
  (activate-mark))

(defun kam-mark-sexp ()
  "Mark symbolic expression at or near point.
Repeat to extend the region forward to the next symbolic expression."
  (interactive)
  (if (and (region-active-p)
           (eq last-command this-command))
      (ignore-errors (forward-sexp 1))
    (when-let* ((thing (cond
                        ((thing-at-point 'url) 'url)
                        ((thing-at-point 'sexp) 'sexp)
                        ((thing-at-point 'string) 'string)
                        ((thing-at-point 'word) 'word))))
      (kam--mark (bounds-of-thing-at-point thing)))))

(defun kam-push-mark-no-activate ()
  "Pushes the `point' to the `mark-ring' and does not activate the region.
Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled."
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))

(defun kam-jump-to-mark ()
  "Jumps to the local mark, respecting the mark-ring order.
This is the same as using \\[set-mark-command] with the prefix argument."
  (interactive)
  (set-mark-command 1))

(defun kam-exchange-point-and-mark-no-activate ()
  "Identical to exchange-point-and-mark but will not activate the region."
  (interactive)
  (exchange-point-and-mark)
  (deactivate-mark nil))

(defun kam-mark-line ()
  "Selects the line."
  (interactive)
  (let (p1 p2)
    (setq p1 (line-beginning-position))
    (setq p2 (line-end-position))
    (push-mark p1 t t)
    (goto-char p2)))

(defun kam-mark-line-with-newline ()
  "Selects the whole line with the newline."
  (interactive)
  (let (p1 p2)
    (setq p1 (save-excursion
               (previous-line)
               (line-end-position)))
    (setq p2 (line-end-position))
    (push-mark p1 t t)
    (goto-char p2)))

(define-advice pop-global-mark (:around (pgm) use-display-buffer)
  "Make `pop-to-buffer' jump buffers via `display-buffer'."
  (cl-letf (((symbol-function 'switch-to-buffer)
             #'pop-to-buffer))
    (funcall pgm)))
#+end_src
**** The =Naved= section that defines the editing commands
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
  (defun kam-cut-dwim ()
    "If the region is active, kill the region. If the region is inactive, kill the whole line. If the point is on an Org heading, kill the subtree."
    (interactive)
    (cond ((region-active-p)
           (kill-region nil nil t))
          ((org-at-heading-p)
           (org-cut-subtree))
          (t (kam-kill-whole-line 1))))

  (defun kam-kill-ring-save-dwim ()
    "If the region is active, copy the region. If the region is inactive, copy the line."
    (interactive)
    (if (region-active-p)
        (copy-region-as-kill nil nil t)
      (progn
        (kam-mark-line-with-newline)
        (kill-ring-save nil nil t))))

  (defun kam-duplicate-line-or-region ()
    "Duplicate the current line or active region."
    (interactive)
    (unless mark-ring
      (push-mark (point) t nil))
    (kam--duplicate-buffer-substring
     (if (region-active-p)
         (cons (region-beginning) (region-end))
       (cons (line-beginning-position) (line-end-position)))))

  (advice-add #'kam-duplicate-line-or-region :after #'kam-indent-region-advice)

  (defun kam-insert-new-line-below (n)
    "Create N empty lines below the current one.
    When called interactively without a prefix numeric argument, N is 1."
    (interactive "p")
    (goto-char (line-end-position))
    (dotimes (_ n) (newline-and-indent)))

  (defun kam-insert-new-line-above (n)
    "Create N empty lines above the current one.
    When called interactively without a prefix numeric argument, N is 1."
    (interactive "p")
    (let ((point-min (point-min)))
      (if (or (bobp)
              (eq (point) point-min)
              (eq (line-number-at-pos point-min) 1))
          (progn
            (goto-char (line-beginning-position))
            (forward-line (- n))
            (dotimes (_ n) (kam-insert-new-line-below n)))
        (forward-line (- n))
        (kam-insert-new-line-below n))))

  (defun kam-yank-replace-line-or-region ()
    "Replace line or region with the latest kill.
    This command can be followed by the standard `yank-pop' (default is bound to \\[yank-pop])."
    (interactive)
    (if (use-region-p)
        (delete-region (region-beginning) (region-end))
      (delete-region (line-beginning-position) (line-end-position)))
    (yank))

  (defun kam-kill-whole-line (n)
    "Kills the whole line, regardless of the cursor position within the line.
    If called interactively without a prefix numeric argument, N is 1."
    (interactive "p")
    (dotimes (_ n)
      (kam-mark-line-with-newline)
      (kill-region (region-beginning) (region-end))))

  (defun kam-comment-dwim (n)
    "Comment N lines, defaulting to the current line.
    When the region is active, comment its lines instead."
    (interactive "p")
    (if (use-region-p)
        (comment-or-uncomment-region
         (region-beginning) (region-end))
      (comment-line n)))

  (defun kam-transpose-char (&optional arg)
    "Interchange the characters behind the point."
    (interactive "p")
    (transpose-chars -1)
    (forward-char))

  (defun kam-kill-sexp (&optional arg interactive)
    "Kill the sexp following point.
    With ARG, do it that many times."
    (interactive "p\nd")
    (if interactive
        (condition-case _
            (kam-kill-sexp arg nil)
          (scan-error (user-error (if (> arg 0)
                                      "No next sexp"
                                    "No previous sexp"))))
      (let ((old-point (point)))
        (kam-forward-sexp (or arg 1))
        (kill-region old-point (point)))))

  (defun kam-kill-sexp (&optional arg interactive)
    "Kill the sexp following point.
    With ARG, do it that many times."
    (interactive "p\nd")
    (if interactive
        (condition-case _
            (kam-kill-sexp arg nil)
          (scan-error (user-error (if (> arg 0)
                                      "No next sexp"
                                    "No previous sexp"))))
      (let ((old-point (point)))
        (kam-forward-sexp (or arg 1))
        (kill-region old-point (point)))))
#+end_src
**** The =Naved= section that defines the navigation commands
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(defun kam-end-of-string ()
  (interactive)
  (while (in-string-p)
    (forward-char 1))
  (point))

(defun kam-beginning-of-string ()
  (interactive)
  (while (in-string-p)
    (forward-char -1))
  (point))

(defun kam-forward-sexp (&optional arg interactive)
  "Move forward across a sexp.
With ARG, do it that many times. Negative ARG -N means move backwards across N sexps.
This command assumes a string or a comment is a sexp."
  (interactive "p\nd")
  (if interactive
      (condition-case _
          (kam-forward-sexp arg nil)
        (scan-error (user-error (if (> arg 0)
                                    "No next sexp"
                                  "No previous sexp"))))
    (if (in-string-p)
        (progn
          (kam-end-of-string)
          (forward-char -1))
      (forward-sexp arg))))

(defun kam-backward-sexp (&optional arg interactive)
  "Move backwards across a sexp.
With ARG, do it that many times. Negative ARG -N means move forward across N sexps.
This command consides a string or a comment a sexp.
Uses `kam-forward-sexp' to do the work."
  (interactive "p\nd")
  (or arg (setq arg 1))
  (if (in-string-p)
      (progn
        (kam-beginning-of-string)
        (forward-char 1))
    (kam-forward-sexp (- arg) interactive)))

(defun kam-narrow-or-widen-dwim (p)
  "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
Intelligently means: region, subtree, or defun, whichever applies first."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((region-active-p)
         (narrow-to-region (region-beginning) (region-end)))
        ((derived-mode-p 'org-mode) (org-narrow-to-subtree))
        (t (narrow-to-defun))))

(defun kam-current-sexp ()
  "Returns the current expression based on the position of the point within or on the edges of an s-expression."
  ;; doesnt work good right now
  (cond
   ((thing-at-point 'url) 'url)
   ((thing-at-point 'word) 'word)
   ((thing-at-point 'string) 'string)
   ((thing-at-point 'sexp) 'sexp)))

(defun kam-current-elisp-sexp ()
  "Returns the current Elisp expression based on the position of the point within or on the edges of an s-expression."
  (cond
   ((looking-at "(") (sexp-at-point))
   ((looking-back ")" 1) (elisp--preceding-sexp))
   (t (save-excursion
        (search-backward "(")
        (sexp-at-point)))))

(defun kam-eval-current-sexp ()
  "Evaluates the current sexp at point.
Unlike `eval-last-sexp', the point doesn't need to be at the end of the expression, but can be at the beginning (on the parenthesis) or somewhere inside."
  (interactive)
  (eval-expression (kam-current-elisp-sexp)))

(defun kam-isearch-symbol-at-point ()
  (interactive)
  (isearch-forward (thing-at-point 'symbol)))

(defun kam-kill-inner-sexp ()
  "Intended to kill everything inside the closest pair of paired delimiters."
  (interactive)
  (sp-kill-sexp 0))

(defun kam-kill-around-sexp ()
  "Kills the everything inside the list at point including the delimiters."
  (interactive)
  (backward-up-list)
  (kam-kill-sexp))

(cl-defmethod register-val-jump-to ((val vector) delete)
  "Handle how to jump to a location register.
This is like the default, but does not ask to visit a file, but does it outright."
  (cond
   ((eq (aref val 0) 'file-with-point)
    (find-file (aref val 1))
    (goto-char (aref val 2)))
   (t (cl-call-next-method val delete))))
#+end_src
**** The =Naved= section that defines the scrolling commands
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(defun kam-multi-line-below ()
  "Move a half screen below."
  (interactive)
  (forward-line (floor (window-height) 2))
  (setq this-command 'scroll-down-command))

(defun kam-multi-line-above ()
  "Move a half screen above."
  (interactive)
  (forward-line (- (floor (window-height) 2)))
  (setq this-command 'scroll-down-command))
#+end_src
**** The =Naved= section that defines commenting commands
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
#+end_src
*** The call to provide =Naved=
:PROPERTIES:
:CUSTOM_ID: h:FCBA1872-E558-435C-9F82-C8F20E9ED025
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-naved.el")
(provide 'kam-naved)
#+end_src
** The =Keybindings= module
*** The =Keybindings= section that defines basic keybindings
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-keybindings.el") :mkdirp yes
(use-package emacs
  :ensure nil
  :bind
  ("<f4>" . #'kam-copy)
  ("<f9>" . next-buffer)
  ("<escape>" . #'kam-keyboard-quit-dwim)
  ("<home>" . nil)
  ("<end>" . nil)
  ("<up>" . nil)
  ("<down>" . nil)
  ("<left>" . nil)
  ("<right>" . nil)
  ([remap keyboard-quit] . #'kam-keyboard-quit-dwim)
  ([remap scratch-buffer] . 'persp-switch-to-scratch-buffer)
  ("C-g" . nil)
  ("C-k" . kill-line)
  ("C-o" . #'kam-ace-window-one-command)
  ("C-v" . set-mark-command)
  ("C-w" . #'kam-cut-dwim)
  ("C-t" . #'kam-transpose-char)
  ("C-z" . zap-to-char)
  ("C-SPC" . #'kam-jump-to-mark)
  ("C-<return>" . #'kam-insert-new-line-below)
  ("C-DEL" . backwards-kill-word)
  ("C-<next>" . scroll-other-window)
  ("C-<prior>" . scroll-other-window-down)
  ("C-," . scroll-other-window)
  ("M-," . scroll-other-window-down)
  ("C-&" . nil)
  ("C-=" . indent-region)
  ("C-^" . nil)
  ("C-$" . jinx-correct-nearest)
  ("C-@" . nil)
  ("C-_" . nil)
  ("C-:" . nil)
  ("C-/" . nil)
  ("C-!" . shell-command)
  ("C-+" . nil)
  ("C-|" . nil)
  ("C-{" . nil)
  ("C-}" . nil)
  ("C-`" . nil)
  ("C-(" . nil)
  ("C-)" . nil)
  ("C-~" . nil)
  ("C-<" . nil)
  ("C->" . nil)
  ("M-c" . capitalize-dwim)
  ("M-i" . scroll-down)
  ("M-l" . downcase-dwim)
  ("M-n" . forward-paragraph)
  ("M-p" . backward-paragraph)
  ("M-q" . upcase-dwim)
  ("M-u" . universal-argument)
  ("M-v" . mark-word)
  ("M-w" . #'kam-kill-ring-save-dwim)
  ("M-z" . zap-up-to-char)
  ("M-!" . async-shell-command)
  ("M-;" . #'kam-comment-dwim)
  ("M-@" . nil)
  ("M-*" . nil)
  ("M-_" . nil)
  ("M-+" . nil)
  ("M-#" . nil)
  ("M-SPC" . #'kam-push-mark-no-activate)
  ("M-<return>" . #'kam-insert-new-line-above)
  ("M-DEL" . backward-kill-sentence)
  ("C-x 1" . nil)
  ("C-x 2" . nil)
  ("C-x 3" . nil)
  ("C-x f" . find-file)
  ("C-x n" . #'kam-narrow-or-widen-dwim)
  ("C-x o" . kam-ace-window-prefix)
  ("C-x v" . er/mark-sentence)
  ("C-x C-e" . #'kam-eval-current-sexp)
  ("C-x C-v" . mark-paragraph)
  ("C-x C-k" . #'delete-window)
  ("H-k" . kill-paragraph)
  ("H-l" . #'kam-consult-imenu-link)
  ("H-i" . scroll-up)
  ("H-m" . kam-mark-line)
  ("H-n" . #'kam-next-buffer)
  ("H-p" . #'kam-prev-buffer)
  ("H-r" . undo-redo)
  ("H-u" . universal-argument)
  ("H-v" . #'kam-mark-line)
  ("H-z" . repeat-complex-command)
  ("H-DEL" . backward-kill-paragraph)
  ("C-M-b" . sp-backward-sexp)
  ("C-M-d" . sp-down-sexp)
  ("C-M-f" . #'sp-forward-sexp)
  ("C-M-k" . #'sp-kill-sexp)
  ("C-M-q". #'kam-kill-inner-sexp)
  ("C-M-u" . sp-backward-up-sexp)
  ("C-M-v" . sp-mark-sexp)
  ("C-M-y" . #'kam-duplicate-line-or-region)
  ("C-M-DEL" . sp-backward-kill-sexp)
  ("C-c f c" . (lambda () (interactive) (find-file "/home/kam/.dotfiles/home-manager/kam-emacs.org")))
  ([remap list-buffers] . ibuffer)
  ([remap exchange-point-and-mark] . #'kam-exchange-point-and-mark-no-activate)
  :config
  (keymap-global-set "<f6>" 'avy-goto-char-timer))
  
  (key-translate "C-i" "H-i")
  (key-translate "C-m" "H-m")
#+end_src
*** The =Keybindings= section that defines =Org-mode= bindings
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-keybindings.el")
(use-package org
  :ensure nil
  :bind
  (:map org-mode-map
        ("H-1" . kam-org-refile-to-current-file-heading)
        ("H-2" . #'kam-consult-org-heading-link)
        ("H-b" . org-previous-visible-heading)
        ("H-f" . org-next-visible-heading)
        ("<f2>" . org-meta-return)
        ("C-," . scroll-up)
        ("M-," . scroll-down)
        ("C-<return>" . kam-insert-new-line-below)
        ("C-<tab>" . #'kam-org-fold-nearest-heading)
        ("C-<f2>" . org-insert-subheading)
        ("<return>" . org-return)
        ("M-j" . point-to-register)
        ("C-j" . consult-register-load)
        ("C-m" . kam-keyboard-quit-dwim)
        ("M-<f2>" . #'kam-org-insert-super-heading)
        ("C-'" . org-edit-src-code)
        ("M-'" . org-edit-src-exit)
        ("M-<up>" . #'kam-org-up-heading)
        ("M-<down>" . #'kam-org-down-heading)
        ("C-M-<up>" . #'kam-org-control-metaup)
        ("C-M-<down>" . #'kam-org-control-metadown)
        ("C-M-<left>" . kam-org-promote-subtrees)
        ("C-M-<right>" . kam-org-demote-subtrees)
        ("C-M-q" . kam-kill-inner-sexp)
        ("C-x C-v" . org-mark-element)
        ("C-c o p" . org-set-property))
  (:map org-src-mode-map
        ("M-'" . org-edit-src-exit)))

(defvar-keymap kam-org-repeat-map
  :repeat t
  :doc "Repeat map for Org"
  "<up>" #'kam-org-up-heading
  "<down>" #'kam-org-down-heading)

(defvar-keymap kam-isearch-repeat-map
  :doc "Repeat map for Isearch"
  :repeat (:enter (isearch-repeat-forward) :exit (isearch-exit))
  "d" #'isearch-repeat-forward
  "n" #'isearch-repeat-backward)
#+end_src
*** The =Keybindings= section that defines the =prefix-map=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-keybindings.el")
  (defvar-keymap kam-prefix-map
    :doc "Prefix map"
    :name "Prefix"
    :prefix 'kam-prefix
    "1" #'delete-window
    "=" #'delete-window
    "2" #'kam-split-window-right
    "(" #'kam-split-window-right
    "3" #'delete-other-windows
    "{" #'delete-other-windows
    "C-f" #'find-file
    "C-d" #'consult-dir
    "C-s" (cons "Search" 'kam-prefix-search)
    "C-r" (cons "ITE" 'kam-prefix-ite)
    "C-o" (cons "Org" 'kam-prefix-org))
#+end_src
*** The =Keybindings= section that defines the =search-map=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-keybindings.el")
(defvar-keymap kam-prefix-search-map
  :doc "Prefix map for searching or going"
  :name "Search"
  :prefix 'kam-prefix-search
  "e" #'consult-compiler-error
  "C-c" #'goto-char
  "C-e" #'consult-isearch-history
  "C-f" #'consult-fd
  "C-g" #'goto-line
  "H-i" #'kam-menu ; translated to C-i
  "k" #'consult-keep-lines
  "C-k" #'consult-global-mark
  "C-l" #'consult-line
  "H-m" #'consult-mark
  "C-o" #'consult-outline
  "C-p" #'kam-consult-line-symbol-at-point
  "C-r" #'consult-ripgrep
  "C-s" #'isearch-forward)
#+end_src
*** The =Keybindings= section that defines the =org-map=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-keybindings.el")
  (defvar-keymap kam-prefix-org-map
    :doc "Prefix map for Org mode."
    :name "Org"
    :prefix 'kam-prefix-org
    "C-w" #'kam-org-refile-to-current-file-heading
    "C-o" #'kam-org-refile-region
    "C-l" #'kam-consult-org-heading-link)

  (keymap-global-set "C-s" kam-prefix-search-map)
  (keymap-global-set "C-r" kam-prefix-map)

#+end_src
*** The =Keybindings= section that provides =Keybindings=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-keybindings.el")
(provide 'kam-keybindings)
#+end_src
** The =OS= module
The OS module is designed to integrate Emacs with the operating system, specifically NixOS.
*** Require =kam-common=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-os.el") :mkdirp yes
(require 'kam-common)
#+end_src
*** Installing Nix-mode
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-os.el")
(use-package nix-mode
   :ensure t
   :mode "\\.nix\\'")
#+end_src
*** Nix Commands
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-os.el")
(defvar kam-dotfiles-directory "~/.dotfiles/")

(defun kam-os-nix-rebuild ()
  "Runs the command nixos-rebuild switch --flake."
  (interactive)
  (kam-common-sudo-shell-command "nixos-rebuild switch --flake ~/.dotfiles/#nixos"))
#+end_src
*** Provide =kam-os=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-os.el")
(provide 'kam-os)
#+end_src
** The =Themes= module
:PROPERTIES:
:CUSTOM_ID: h:88A597D4-AEF0-4AA9-B147-F7AF0F80B3B5
:END:
*** Use case
:PROPERTIES:
:CUSTOM_ID: h:739A9D33-046A-4176-883E-11BA86F77F43
:END:
*** The =Themes= section that sets up =Modus Themes=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-themes.el")
(use-package modus-themes
  :ensure t
  :config
  (setq modus-themes-disable-other-themes t
        modus-themes-italic-constructs t
        modus-themes-bold-constructs t
        modus-themes-mixed-fonts t
        modus-themes-prompts '(heavy)
        modus-themes-org-blocks nil
        modus-themes-completions '((selection . (bold)))
        modus-theme-headings '((1 . (variable-pitch 1.5))
                               (2 . (variable-pitch 1.3))
                               (3 . (variable-pitch 1.1))
                               (t . (variable-pitch 1)))
        
        modus-vivendi-palette-user '((kam-comment "#ff7f24")
                                     (kam-constant "#7fffd4")
                                     (kam-fnname "#87cefa")
                                     (kam-keyword "#00ffff")
                                     (kam-preprocessor "#b0c4de")
                                     (kam-string "#ffa07a")
                                     (kam-type "#98fb98")
                                     (kam-variable "#eedd82"))
        
        modus-vivendi-palette-overrides '(
                                          (bg-main "#000000")
                                          (bg-active bg-main)
                                          ;; (bg-mode-line-active bg-blue-subtle)
                                          ;; (border-mode-line-active unspecified)
                                          ;; (fg-region unspecified)
                                          ;; (bg-heading-1 bg-main)
                                          ;; (fg-heading-1 fg-main)
                                          ;; (fg-heading-2 fg-changed)
                                          ;; (bg-heading-2 bg-main)
                                          ;; (fg-heading-3 blue-cooler)
                                          ;; (bg-heading-3 and bg-main)
                                          ;; (builtin "#b0c4de")
                                          ;; (Comment "#ff7f24") ;; these ;custom values are taken from standard-themes-dark
                                          (constant "#7fffd4")
                                          (fnname "#87cefa")
                                          (keyword "#00ffff")
                                          (preprocessor "#b0c4de")
                                          (docstring "#ffa07a")
                                          (string "#ffa07a")
                                          (type "#98fb98")
                                          (variable "#eedd82")
                                          (rx-escape "#44cc44")
                                          (rx-construct "#ffffff")
                                          (fg-prompt cyan)
                                          ;; (bg-prompt unspecified)
                                          (fg-completion-match-0 fg-main)
                                          ;; (bg-completion-match-0 unspecified)
                                          (fg-completion-match-1 fg-main)
                                          (bg-prose-block-delimiter "#312f34")
                                          (bg-prose-block-contents "#29272c")
                                          ;; (bg-completion-match-1 unspecified)
                                          ))

  (defun kam-set-custom-faces (&rest _)
    "Function which sets faces across the configuration using the `modus-themes-with-colors' macro."
    (modus-themes-with-colors
      (custom-set-faces
       `(region ((,c :extend nil)))
       `(org-special-keyword ((,c :inherit fixed-pitch :height .8 :foreground ,fg-dim)))
       `(org-meta-line ((,c :inherit fixed-pitch :height .8 :foreground ,fg-dim)))
       `(org-document-title ((,c :inherit fixed-pitch :height .8 :foreground ,fg-dim)))
       `(org-document-info ((,c :inherit fixed-pitch :height .8 :foreground ,fg-dim)))
       `(org-document-info-keyword ((,c :inherit fixed-pitch :height .8 :foreground ,fg-dim)))
       `(org-drawer ((,c :inherit fixed-pitch :height .8 :foreground ,fg-dim)))
       `(org-property-value ((,c :inherit fixed-pitch :height .8 :foreground ,fg-dim)))
       `(org-ellipsis ((,c :height 1.0 :foreground ,fg-dim)))
       `(org-block-end-line ((,c :background ,bg-main)))
       `(olivetti-fringe ((,c :background ,bg-main))))))

  (defun kam-modus-themes-org-block-faces (&rest _)
    "Function for setting custom org block faces."
    (modus-themes-with-colors
      (setq org-src-block-faces
            `(("emacs-lisp" bg-dim)))))

  (add-hook 'modus-themes-post-load-hook #'kam-set-custom-faces)
  (add-hook 'modus-themes-post-load-hook #'kam-modus-themes-org-block-faces))
  #+end_src
*** The =Themes= section that sets up =EF Themes=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-themes.el")
(use-package ef-themes
  :ensure
  (:host github :repo "protesilaos/ef-themes"))
#+end_src
*** The =Themes= section that sets up =Olivetti=
:PROPERTIES:
:CUSTOM_ID: h:216AA5B4-C126-4271-9F4F-B34DE364E881
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-themes.el")
(use-package olivetti
  :ensure t
  :config
  (setq olivetti-style 'fancy
        olivetti-margin-width 5
        olivetti-body-width .7
        ;; olivetti-minimum-body-width 80
         olivetti-recall-visual-line-mode-entry-state t))

#+end_src
*** The =Themes= section that sets up =Spacious Padding=
:PROPERTIES:
:CUSTOM_ID: h:DA5B3A2F-EF18-45BF-84C0-31FED395BD50
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-themes.el")
(use-package spacious-padding
  :ensure
  (:host "github" :repo "protesilaos/spacious-padding")
  :config
  (setq spacious-padding-subtle-mode-line
        `( :mode-line-active "#fec43f"
           :mode-line-inactive 'vertical-border))
  (setq spacious-padding-widths
        '( :internal-border-width 15
           :header-line-width 4
           :mode-line-width 8
           :tab-width 4
           :right-divider-width 30
           :scroll-bar-width 8
           :fringe-width 4)
        spacious-padding-subtle-mode-line t)
  (spacious-padding-mode))
#+end_src
*** The =Themes= section that sets up my =modeline=
:PROPERTIES:
:ID:       81aad2f2-a0f6-4b9a-a657-23451985e93d
:END:
This is the section that sets the default modeline format. The goal of the modeline is to look nice, but also to show useful information in an easy to read way. The default modeline looks pretty bad, none of the information is spaced correctly, and worst of all shows information in an almost cryptic way. Not to mention the information it shows that isn't needed at all.

The majority of the functions are written in the [[id:90ecc2e2-ec44-444f-a373-6aca647070e7][modeline library]].
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-themes.el")
(setq mode-line-compact nil
      mode-line-right-align-edge 'right-fringe)

(setq-default mode-line-format
              '("%e"
                kam-modeline-kbd-macro
                kam-modeline-narrow
                kam-modeline-buffer-modified
                kam-modeline-buffer-status
                "  "
                kam-modeline-buffer-identification
                " "
                kam-modeline-major-mode
                kam-modeline-process
                " "
                mode-line-format-right-align
                kam-modeline-vc-branch))

(with-eval-after-load 'spacious-padding
  (defun kam-modeline--spacious-indicators ()
    "Set box attribute to `'kam-modeline-indicator-button' if spacious-padding is enabled."
    (if (bound-and-true-p spacious-padding-mode)
        (set-face-attribute 'kam-modeline-indicator-button nil :box t)
      (set-face-attribute 'kam-modeline-indicator-button nil :box 'unspecified)))

  (kam-modeline--spacious-indicators)
  (add-hook 'spacious-padding-mode-hook #'kam-modeline--spacious-indicators))
#+end_src
*** The =Themes= section that sets up my =header-line=
The header line in my Emacs is driven primarily by [[id:d015e408-3572-462e-861a-84de470f4ec3][Breadcrumb]], but I am going to set the header line format here so that I can center the Breadcrumb text
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-keybindings.el")
;; (setq header-line-format
;;       `((""
;;          header-line-indent
;;          ,breadcrumb--header-line)))
#+end_src
*** The =Themes= section that sets up =Logos=
:PROPERTIES:
:CUSTOM_ID: h:6D85E383-3981-4C92-A294-D36FA6DC09FC
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-themes.el")
(use-package logos
  :ensure
  (:host "github" :repo "protesilaos/logos")
  :config
  (setq-default logos-hide-mode-line t
                logos-hide-header-line t
                logos-hide-buffer-boundaries t
                logos-hide-fringe nil
                logos-olivetti t))
#+end_src
*** The =Themes= section for =Fontaine=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-themes.el")
(use-package fontaine
  :ensure
  (:host "github" :repo "protesilaos/fontaine")
  :config
  (setq fontaine-latest-state-file (locate-user-emacs-file "fontaine-latest-state.eld")))
#+end_src
*** The =Themes= section for =Lin=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-themes.el")
(use-package lin
  :ensure
  (:host "github" :repo "protesilaos/lin")
  :config
  (setq lin-face 'lin-yellow)
  (lin-global-mode 1))
#+end_src
*** The =Themes= section for =Cursory=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-themes.el")
(use-package cursory
  :ensure
  (:host "github" :repo "protesilaos/cursory"))
#+end_src
*** The =Themes= section for =Pulsar=
For use with Avy.
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-themes.el")
(use-package pulsar
  :ensure
  (:host "github" :repo "protesilaos/pulsar")
  :hook ((next-error . pulsar-pulse-line)
         (minibuffer-setup . pulsar-pulse-line)
         (consult-after-jump . pulsar-recenter-top)
         (consult-after-jump . pulsar-reveal-entry)
         (imenu-after-jump . pulsar-recenter-top)
         (imenu-after-jump . pulsar-reveal-entry))
  :config
  (setq pulsar-pulse t
        pulsar-face 'ansi-color-yellow)
  (pulsar-global-mode)

  (add-to-list 'pulsar-pulse-functions 'avy-goto-char-timer)
  (add-to-list 'pulsar-pulse-functions 'pixel-scroll-interpolate-down)
  (add-to-list 'pulsar-pulse-functions 'pixel-scroll-interpolate-up)
  (add-to-list 'pulsar-pulse-functions 'ace-window))

#+end_src 
*** The =Themes= section that sets up icons
:PROPERTIES:
:CUSTOM_ID: h:1187DBE8-7AC4-4A4C-8FF7-40067F0818D6
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-themes.el")
(use-package all-the-icons
  :if (display-graphic-p)
  :commands all-the-icons-install-fonts
  :init
  (unless (find-font (font-spec :name "all-the-icons"))
    (all-the-icons-install-fonts t))
  :config
  (setq all-the-icons-scale-factor 1.1))

(use-package all-the-icons-ibuffer
  :ensure t
  :config
  (all-the-icons-ibuffer-mode 1))

(use-package all-the-icons-dired
  :config
  (setq all-the-icons-dired-monochrome nil)
  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))

(use-package all-the-icons-completion 
  :ensure t
  :after (marginalia)
  :config
  (all-the-icons-completion-mode)
  (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))

(use-package nerd-icons
  :config
  (setq nerd-icons-font-family "SauceCodePro Nerd Font"))

#+end_src

*** The =Themes= sets that sets up fonts
:PROPERTIES:
:CUSTOM_ID: h:96ADA93B-F10F-49F4-BEC6-76E082CF28B7
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-themes.el")
(defun kam-set-font-faces ()
  (set-face-attribute 'default nil :font "SauceCodePro Nerd Font" :height 130 :weight 'regular)
  (set-face-attribute 'fixed-pitch nil :font "Iosevka Comfy" :height 1.0 :weight 'regular)
  (set-face-attribute 'variable-pitch nil :family "Georgia" :height 1.0 :weight 'regular)
  (set-face-attribute 'mode-line nil :font "SauceCodePro Nerd Font Mono" :height .9 :weight 'regular)
  (set-face-attribute 'mode-line-active nil :font "SauceCodePro Nerd Font Mono" :height .9  :weight 'regular)
  (set-face-attribute 'mode-line-inactive nil :family "SauceCodePro Nerd Font Mono" :height .9 :weight 'regular))

(defun prog-mode-buffer-variable ()
  "Intended to set the font in prog mode"
  (interactive)
  (setq buffer-face-mode-face 'fixed-pitch)
  (buffer-face-mode))

;; (add-hook 'text-mode-hook #'variable-pitch-mode)
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
(add-hook 'org-mode-hook #'variable-pitch-mode)
(add-hook 'prog-mode-hook 'prog-mode-buffer-variable)
(add-hook 'info-mode-hook #'variable-pitch-mode)

(global-font-lock-mode 1)
(setq font-lock-maximum-decoration t
      font-lock-maximum-size nil
      font-lock-support-mode 'jit-lock-mode
      font-lock-multiline t
      jit-lock-stealth 0.5
      jit-lock-defer-contextually t
      jit-lock-stealth-time 16)

(setq x-underline-at-descent-line nil
      inhibit-compacting-font-caches nil)
#+end_src

#+RESULTS:
*** The =Themes= section that sets up the Emacs Daemon Make Frame
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-themes.el")

#+end_src
*** The call to provide =Themes=
:PROPERTIES:
:CUSTOM_ID: h:8C9E8882-01E5-4821-B4F4-1A587EBF0E67
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-themes.el")
(provide 'kam-themes)
#+end_src
** The =Window= module
:PROPERTIES:
:CUSTOM_ID: h:1AFC596B-DCCD-4B19-B10C-11D5FE19AE98
:END:
*** The =Window= section that sets up =Ace Window=
:PROPERTIES:
:CUSTOM_ID: h:59604AA1-4055-45DA-8F49-425565229423
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-window.el") :mkdirp yes
(use-package ace-window
  :ensure t
  :bind
  ("<f7>" . ace-window)
  ("C-<f7>" . kam-ace-window)
  :config
  (setq aw-dispatch-always nil
        aw-keys '(?d ?n ?r ?e ?t ?a)
        aw-dispatch-alist
        '((?x aw-delete-window "Delete Window")
	      (?m aw-swap-window "Swap Windows")
	      (?M aw-move-window "Move Window")
	      (?c aw-copy-window "Copy Window")
	      (?j aw-switch-buffer-in-window "Select Buffer")
	      (?u aw-switch-buffer-other-window "Switch Buffer Other Window")
	      (?c aw-split-window-fair "Split Fair Window")
	      (?v aw-split-window-vert "Split Vert Window")
	      (?b aw-split-window-horz "Split Horz Window")
	      (?o delete-other-windows "Delete Other Windows")
	      (?? aw-show-dispatch-help)))
  (ace-window-display-mode)

  (defun kam-ace-window (&optional arg)
    "Small wrapper for `ace-window' that doesn't use the dispatcher."
    (interactive)
    (let ((aw-dispatch-always t))
      (ace-window arg))))
#+end_src
*** The =Window= section about the =display-buffer-alist= and side slots
:PROPERTIES:
:CUSTOM_ID: h:5EC3C7E9-D2C8-424D-B8EE-C4FED822C800
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-window.el")
(setq display-buffer-alist
      '(("\\*Info\\*"
         (display-buffer-in-side-window)
         (side . right)
         (window-width . 80)
         (inhibit-same-window . t)
         (mode Info-mode))
        ("\\*Help\\*"
         (display-buffer-in-side-window)
         (side . right)
         (window-width . 80)
         (inhibit-same-window . t)
         (mode help-mode)
         (window-parameters . ((mode-line-format . none))))
        ("\\*Org Links\\*" ;; Org Links
         (display-buffer-no-window)
         (allow-no-window . t))
        ("\\*Org Select\\*" ;; `org-capture' key selection
         (display-buffer-in-direction)
         (direction . below)
         (window . root)
         (window-height . 0.5)
         (window-parameters . ((mode-line-format . none))))
        ("\\*Org Agenda\\*"
         (display-buffer-in-side-window)
         (side . right)
         (window-width . 80)
         (inhibit-same-window . t)
         (mode . Org-agenda-mode)
         (window-parameters . ((mode-line-format . none))))
        ("\\(\\*Capture\\*\\|CAPTURE-.*\\)"
         (display-buffer-in-direction)
         (direction . below)
         (window . root)
         (window-height . 0.3)
         (window-parameters . ((mode-line-format . none))))
        ("\\*Async Shell Command\\*"
         (display-buffer-in-direction)
         (direction . below)
         (window . root)
         (window-height . 0.35)
         (window-parameters . ((mode-line-format . none))))
        ("Output\\*$"
         (display-buffer-in-direction)
         (direction . below)
         (window . root)
         (window-height . 0.35)
         (window-parameters . ((mode-line-format . none))))
        ("\\*compilation\\*"
         (display-buffer-in-direction)
         (direction . below)
         (window . root)
         (window-height . 0.35)
         (window-parameters . ((mode-line-format . none))))
        ("\\*Backtrace\\*"
         (display-buffer-in-direction)
         (direction . below)
         (window . root)
         (window-height . 0.35)
         (window-parameters . ((mode-line-format . none))))
        ("\\*eshell[\*\:]" ; matches title for reg eshell and `kam-eshell-here'
         (display-buffer-in-side-window)
         (side . right)
         (window-width . 80)
         (inhibit-same-window . t)
         (mode . eshell-mode)
         (window-parameters . ((mode-line-format . none))))))

(setq window-sides-slots '(1 0 1 0))
#+end_src 
*** The =Window= section that enables =Winner-mode=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-window.el")
(winner-mode)
#+end_src
*** The =Window= section that sets up =Popper=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-window.el")
(use-package popper
  :ensure t
  :bind (("<f8>" . popper-toggle)
         ("C-<f8>" . popper-cycle)
         ("C-M-`" . popper-toggle-type))
  :init
  (setq popper-reference-buffers
        '(("\\*Messages\\*" . hide)
          ("Output\\*$" . hide)
          ("\\*Async Shell Command\\*" . hide)
          ("\\Org Agenda\\*" . hide)
          ("\\*Backtrace\\*" . hide)
          ("\\*Warnings\\*" . hide)
          ("\\*eshell[\:\*]")
          help-mode
          compilation-mode
          Info-mode)
        popper-display-control nil)
  (popper-mode)
  (popper-echo-mode))
#+end_src
*** The =Window= section about =balanced-windows=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-window.el")
(use-package balanced-windows
  :ensure t
  :config
  (balanced-windows-mode))
#+end_src
*** The =Window= section about =Breadcrumb=
:PROPERTIES:
:ID:       d015e408-3572-462e-861a-84de470f4ec3
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-window.el") 
;; (use-package breadcrumb
;;   :ensure t
;;   :functions (kam-breadcrumb-local-mode)
;;   :hook ((text-mode prog-mode) . kam-breadcrumb-local-mode)
;;   :config
;;   (setq breadcrumb-project-max-length 0.5
;;         breadcrumb-project-crumb-seperator "/"
;;         breadcrumb-imenu-max-length 1.0
;;         breadcrumb-imenu-crumb-seperator " > ")

;;   (defun kam-breadcrumb-local-mode ()
;;     "Enable `breadcrumb-local-mode' if the buffer is visiting a file."
;;     (when buffer-file-name
;;       (breadcrumb-local-mode 1))))
#+end_src
*** The =Window= section for Beframed
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-window.el")
(use-package beframe
  :ensure
  (:host "github" :repo "protesilaos/beframe")
  :config
  (setq beframe-global-buffers '("*scratch*" "*Messages*" "*Backtrace*")
        beframe-functions-in-frames '())
  (beframe-mode)

  (defvar consult-buffer-sources)
  (declare-function consult--buffer-state "consult")

  (with-eval-after-load 'consult
    (defface beframe-buffer
      '((t :inherit font-lock-string-face))
      "Face for `consult' framed buffers.")

    (defun kam-beframe-buffer-names-sorted (&optional frame)
      "Return the list of buffers from `beframe-buffer-names' sorted by visibility.
With optional argument FRAME, return the list of buffers of FRAME."
      (beframe-buffer-names frame :sort #'beframe-buffer-sort-visibility))

    (defvar beframe-consult-source
      `( :name "Buffers"
          :narrow ?F
          :category buffer
          ; :face beframe-buffer
          :history beframe-history
          :items ,#'kam-beframe-buffer-names-sorted
          :action ,#'switch-to-buffer
          :state ,#'consult--buffer-state))

    (add-to-list 'consult-buffer-sources 'beframe-consult-source)

    (defvar consult-initial-narrow-config
      '((consult-buffer . ?F)))

    (defun kam-consult-initial-narrow ()
      (when-let (key (alist-get this-command consult-initial-narrow-config))
        (setq unread-command-events (append unread-command-events (list key 32)))))

    (add-hook 'minibuffer-setup-hook #'kam-consult-initial-narrow)))
#+end_src
*** The =Window= section for custom lisp
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-window.el")
(defun kam-ace-window-prefix ()
  "Use `ace-window' to display the buffer of the next command.
  The next buffer is the buffer displayed by the next command invoked immediately after this command (ignoring reading from the minibuffer a new window before displaying the buffer.
  When `switch-to-buffer-obey-display-actions' is non-nil, `switch-to-buffer' commands are also supported."
  (interactive)
  (if (one-window-p) (split-window-right))
  (display-buffer-override-next-command
   (lambda (buffer _)
     (let (window type)
       (setq
        window (aw-select (propertize " ACE" 'face 'mode-line-highlight))
        type 'reuse)
       (cons window type)))
   nil "[ace-window]")
  (message "Use `ace-window' to display next command buffer"))

(defun kam-ace-window-one-command ()
  "Select a window with `ace-window' and run any command in that window."
  (interactive)
  (if (one-window-p) (split-window-right))
  (let ((win (aw-select " ACE")))
    (when (windowp win)
      (with-selected-window win
        (let* ((command (key-binding
                         (read-key-sequence
                          (format "Run in %s..." (buffer-name)))))
               (this-command command))
          (call-interactively command))))))

(defun kam-next-buffer (&optional arg)
  "Swith to the next ARGth buffer.
With a universal prefix arg, run in the next window."
  (interactive "P")
  (if-let (((equal arg '(4)))
           (win (other-window-for-scrolling)))
      (with-selected-window win
        (next-buffer)
        (setq prefix-arg current-prefix-arg))
    (next-buffer arg)))

(defun kam-prev-buffer (&optional arg)
  "Switch to the previous ARGth buffer.
With a universal prefix arg, run in the next window."
  (interactive "P")
  (if-let (((equal arg '(4)))
           (win (other-window-for-scrolling)))
      (with-selected-window win
        (previous-buffer)
        (setq prefix-arg current-prefix-arg))
    (previous-buffer arg)))

(defun kam-switch-to-buffer (&optional arg)
  (interactive "P")
  (run-at-time
   0 nil
   (lambda (&optional arg)
     (if-let (((equal arg '(4)))
              (win (other-window-for-scrolling)))
         (with-selected-window win
           (call-interactively #'consult-buffer))
       (call-interactively #'consult-buffer)))
   arg))

(defun kam-split-window-right ()
  "Like the normal `split-window-right' but selects the newly formed window."
  (interactive)
  (split-window-right)
  (windmove-right))

(defun kam-split-window-below ()
  "Like the normal `split-window-below', but splits the window at the root if there are two windows. Additionally selects the newly formed window."
  (interactive)
  (if (kam-common-two-windows-p)
      (split-root-window-below)
    (split-window-below)))

(defun kam-alternate-buffer (&optional window)
  "Return the last buffer WINDOW has displayed other than the current one."
  (let* ((prev-buffers (window-prev-buffers))
         (head (car prev-buffers)))
    (if (eq (car head) (window-buffer window))
        (cadr prev-buffers)
      head)))

(defun kam-switch-to-alternate-buffer ()
  "Switch to the last window used."
  (interactive)
  (let* (alt-buffer (kam-altenate-buffer))
    (switch-to-buffer alt-buffer)))

(defvar-keymap kam-window-map
  :doc"Keymap for windows related actions"
  :repeat t
  "n" #'kam-next-buffer
  "p" #'kam-prev-buffer
  "b" #'kam-switch-to-buffer
  "u" #'winner-undo)
#+end_src
*** The =Window= section about various settings
:PROPERTIES:
:CUSTOM_ID: h:0FFAFB70-AA26-474E-A80D-9157B136344A
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-window.el")
(setq switch-to-buffer-in-dedicated-window 'pop
      switch-to-buffer-obey-display-actions t
      cursor-in-non-selected-windows nil
      switch-to-buffer-preserve-window-point t
      help-window-select t
      help-window-keep-selected t)
#+end_src
*** The call to provide =Window=
:PROPERTIES:
:CUSTOM_ID: h:480FECE2-CB13-432A-8E14-8732C702CDDF
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-window.el")
(provide 'kam-window)
#+end_src
** The =Books= module
:PROPERTIES:
:CUSTOM_ID: h:5FB4541E-F907-4424-AF92-79D13478F664
:END:
*** The =Books= section that sets up =Calibredb=
:PROPERTIES:
:CUSTOM_ID: h:4975553E-EE29-4152-A762-CCC9CA107ABA
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-books.el") :mkdirp yes
(use-package calibredb
  :defer t
  :config
  (setq calibredb-format-all-the-icons t
        calibredb-root-dir "~/Documents/Resources/Books"
        calibredb-db-dir (expand-file-name "metadata.db" calibredb-root-dir)
        calibredb-library-alist '(("~/Documents/Resources/Books"))
        calibredb-sort-by 'title))
#+end_src
*** The =Books= section that sets up =Pdf-tools=
:PROPERTIES:
:CUSTOM_ID: h:C2F2FA7D-E90D-455A-ADD1-FB0A77EDAD92
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-books.el")
(use-package pdf-tools
  :config
  (pdf-tools-install))
#+end_src
*** The =Books= section that sets up =Nov= 
:PROPERTIES:
:CUSTOM_ID: h:05D4480D-A8F4-4745-981A-207E421CBE30
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-books.el")
(use-package nov
  :config
  (setq nov-text-width 80))
(add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
#+end_src
*** The =Books= section that sets up =Nov-Xwidget=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-books.el")
 ;; (use-package nov-xwidget
 ;;   :ensure t
 ;;   :after nov
 ;;   :hook (nov-mode . 'nov-xwidget-inject-all-files)
 ;;   :bind (:map nov-mode-map
 ;;               ("o" . 'nov-xwidget-view)))
#+end_src
*** The =Books= section that makes text files readable
:PROPERTIES:
:CUSTOM_ID: h:37992BE2-5D75-4483-AF6A-2218B57FB171
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-books.el")
(use-package text-mode
  :ensure nil
  :hook (text-mode . variable-pitch-mode))
#+end_src
*** The =Books= section that contains custom lisp
:PROPERTIES:
:CUSTOM_ID: h:02D98B2D-FF0E-4EBD-8B13-C7382A38B551
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-books.el")
(defun kam-calibredb-open-file-with-emacs (&optional candidate)
  "Open file with Emacs. Optional argument CANDIDATE is the selected item."
  (interactive "P")
  (unless candidate
    (setq candidate (car (calibredb-find-candidate-at-point))))
  (find-file (calibredb-get-file-path  candidate t)))

(defun kam-search-books ()
  (interactive)
  (let ((consult-ripgrep-command "rg --null --ignore-case --type txt --line-number . --color always --max-columns 500 --no-heading -e ARG OPTS"))
    (consult-ripgrep calibredb-root-dir)))
#+end_src
*** The call to provide =Books=
:PROPERTIES:
:CUSTOM_ID: h:10F5F5E7-7512-4EC8-924D-D9DA486C7E3F
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-books.el")
(provide 'kam-books)
#+end_src
** The =Comint= module
*** Keybindings
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-comint.el") :mkdirp yes
;;; -*- lexical-binding: t; -*-
(use-package emacs
  :ensure nil
  :bind
  (:map comint-mode-map
        ("C-c C-l" . #'kam-consult-comint-history)
        ("C-." . #'kam-comint-insert-arguments-from-command)))
#+end_src
*** The =Comint= section for =shell-mode=
:PROPERTIES:
:CUSTOM_ID: h:8082CEBF-DCD1-43A4-A246-920408F81492
:END:
**** The =Shell= section for keybindings
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-comint.el")
;; (use-package emacs
;; :ensure nil
;; :bind
;; (:map shell-mode-map
;; ("C-c C-d" . #'kam-shell-cd)
;; ("C-c C-j" . #'kam-comint-input-from-history)))
#+end_src
**** The =Shell= section that sets the shell settings
:PROPERTIES:
:CUSTOM_ID: h:AEAF747B-0541-4A7B-A23D-33BB3F6C423A
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-comint.el")
(use-package shell
  :ensure nil
  ;; :hook (shell-mode-hook . #'kam-shell-mode-setup)
  ;; :bind
  ;; (:map shell-mode-map
  ;; ("SPC" . 'comint-magic-space))
  :config
  (setq shell-command-prompt-show-cwd t
        explicit-zsh-args '("--login" "--interactive")
        explicit-shell-file-name (executable-find "bash")
        ansi-color-for-comint-mode t
        shell-kill-buffer-on-exit t
        comint-prompt-read-only t
        comint-buffer-maximum-size 9999
        comint-input-ignoredups t))

(add-hook 'shell-mode-hook #'kam-shell-mode-setup)

(defun kam-shell-mode-setup ()
  (setq-local comint-process-echoes t
              outline-regexp comint-prompt-regexp)
  (add-hook 'comint-output-filter-functions #'kam-shell--track-cd))
#+end_src
**** The =Shell= section for custom lisp
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-comint.el")
;;; -*- lexical-binding: t; -*-
(defvar kam-shell-cd--directories nil
  "List of accumulated `shell-last-dir'.")

(with-eval-after-load 'savehist
  (add-to-list 'savehist-additional-variables 'kam-shell-cd--directories))

(defun kam-shell--track-cd (&rest _)
  "Track shell input of cd commands.
Push `shell-last-dir' to `kam-shell-cd--directories'."
  (when-let ((input (kam-comint--last-input))
             ((string-match-p "cd " input)))
    (push shell-last-dir kam-shell-cd--directories)))

(defvar kam-shell-cd--history nil
  "Minibuffer history for `kam-shell-cd'.")

(defun kam-shell-cd--prompt ()
  "Prompt for a directory among `kam-shell-cd--directories'."
  (if-let ((history kam-shell-cd--directories)
           (dirs (cons default-directory history))
           (def (if (listp dirs) (car dirs) shell-last-dir)))
      (completing-read
       (format-prompt "Select directory: " def)
       dirs
       nil
       nil
       nil
       'kam-shell--cd-history)
    (user-error "No directories have been tracked")))

(defun kam-shell-cd ()
  "Navigate to a previously visited directory in Shell, or to any directory offered by `consult-dir'."
  (declare (interactive-only t))
  (interactive)
  (let ((shell-dirs (delete-dups
                     (mapcar 'abbreviate-file-name
                             (remove nil
                                     kam-shell-cd--directories)))))
    (cond
     ((featurep 'consult-dir)
      (let* ((consult-dir--source-shell `(:name "Shell"
                                                :narrow ?s
                                                :category file
                                                :face consult-file
                                                :items ,shell-dirs))
             (consult-dir-sources (cons consult-dir--source-shell
                                        consult-dir-sources)))
        (kam-comint--insert-and-send "cd"
                                     (substring-no-properties
                                      (consult-dir--pick "Switch directory: "))))))))

(defun kam-shell-here ()
  "Opens a new shell in the directory associated with the current buffer's file.
The shell is renamed to match that directory to make multiple shell windows easier."
  (interactive)
  (let* ((parent (if (buffer-file-name)
                     (file-name-directory (buffer-file-name))
                   default-directory))
         (name (car (last (split-string parent "/" t)))))
    (split-window-right)
    (other-window 1)
    (shell)
    (rename-buffer (concat "*shell: " name "*"))))

(defun kam-shell-up-directory ()
  "Navigates a directory higher in the directory tree."
  (interactive)
  (kam-comint--insert-and-send "cd .."))
#+end_src
*** The =Comint= section with custom lisp
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-comint.el")
(defun kam-comint--beginning-of-prompt-p ()
  "Return non-nil if the point is at the beginning of a shell prormpt."
  (if comint-use-prompt-regexp
      (looking-back comint-prompt-regexp
                    (line-beginning-position))
    (eq (point) (comint-line-beginning-position))))

(defun kam-comint--insert-and-send (&rest args)
  "Insert and execute ARGS in the last Comint prompt.
ARGS is a list of strings."
  (if (kam-comint--beginning-of-prompt-p)
      (progn
        (insert (mapconcat #'identity args " "))
        (comint-send-input))
    (user-error "Not at the beginning of prompt; won't insert: %s" args)))

(defun kam-comint--insert (&rest args)
  "Insert ARGS in the last Comint prompt.
ARGS is a list of strings."
  (if (kam-comint--beginning-of-prompt-p)
      (insert (mapconcat #'identity args " "))
    (user-error "Not at the beginning of prompt; won't insert: %s" args)))

(defun kam-comint--last-input ()
  "Return the last input as a string."
  (buffer-substring-no-properties
   comint-last-input-start
   comint-last-input-end))

(defun kam-comint--history-to-list ()
  "Returns the current Comint buffer's history as a list."
  (when (and (ring-p comint-input-ring)
             (not (ring-empty-p comint-input-ring)))
    (let (history)
      (dotimes (index (ring-length comint-input-ring))
        (push (ring-ref comint-input-ring index) history))
      (delete-dups history)
      (setq history (nreverse history))
      history)))

(defvar kam-comint--input-history-prompt nil
  "Minibuffer history of `kam-comint--input-history-prompt'.
Not to be confused with the shell input history, which is stored in the `comint-input-ring' (see `kam-comint--history-to-list').")

(defun kam-comint--input-history-prompt ()
  "Prompt for completion against `kam-comint--history-to-list'."
  (let* ((history (kam-comint--history-to-list))
         (default (car history)))
    (completing-read
     (format-prompt "Insert input from history: " default)
     history
     nil
     nil
     nil
     'kam-comint--input-history-prompt
     default)))

(defun kam-comint-input-from-history ()
  "Insert command from the Comint input history."
  (declare (interactive-only t))
  (interactive)
  (kam-comint--insert-and-send
   (kam-comint--input-history-prompt)))

(defun kam-comint--get-args (command)
  "Gets the arguments from a given COMMAND, where COMMAND is a string."
  (let ((args (comint-arguments command 1 nil)))
    (split-string args)))

(defun kam-comint-insert-arguments-from-command (&optional arg)
  "Insert any number of arguments from a previously run command using minibuffer completion.
If there is a numerical argument, the arguments are selected from the ARGth run command."
  (interactive "p")
  (kam-comint--insert
   (kam-comint--get-args-prompt arg)))

(defun kam-comint--get-args-prompt (&optional arg)
  "Select an argument from a previously run command using minibuffer completion.
Numerical argument ARG determines the command being selected from to choose arguments."
  (interactive "p")
  (let* ((command-index (or (- 1 arg) 1))
         (command (nth command-index (kam-comint--history-to-list)))
         (args (kam-comint--get-args command))
         (default (car args)))
    (completing-read
     (format-prompt "Select Arg: " default)
     args
     nil
     t
     nil
     nil
     default
     nil)))
#+end_src
*** The =Comint= section to provide =Comint=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-comint.el")
(provide 'kam-comint)
#+end_src
** The =Calendar= module
:PROPERTIES:
:CUSTOM_ID: h:6B6AB7D5-0FEF-4A89-8A23-9A803B1DCD21
:END:
*** Integrating =Calendar= with =Org Mode=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-calendar.el") :mkdirp yes
(use-package calendar
  :ensure nil
  :config)
#+end_src
*** Call to provide =Calendar=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-calendar.el")
(provide 'kam-calendar)
#+end_src
** The =Dired= module
:PROPERTIES:
:CUSTOM_ID: h:8222A7B8-A808-48B0-9C0B-0F13346242C8
:END:
*** The =Dired= section that silences the confirmation messages
:PROPERTIES:
:CUSTOM_ID: h:B5774001-C854-45A8-B433-EFB2838CDEA9
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-dired.el") :mkdirp yes
(use-package dired
  :ensure nil
  :config
  (setq dired-clean-confirm-killing-deleted-buffers nil
        dired-confirm-shell-command nil
        dired-no-confirm t
        dired-deletion-confirmer '(lambda (x) t)))
#+end_src
*** The =Dired= section for the listing switches
:PROPERTIES:
:CUSTOM_ID: h:1AB9633D-6CD3-4622-81B1-5AAEA878E0EA
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-dired.el")
(use-package dired
  :ensure nil
  :config
  (setq dired-listing-switches "-AGFhlv --group-directories-first --time-style=long-iso"))
#+end_src
*** The =Dired= section for miscellaneous settings
:PROPERTIES:
:CUSTOM_ID: h:0A8105D4-4F58-4D4E-B52F-EB03074E3079
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-dired.el")
(use-package dired
  :ensure nil
  :hook (dired-mode . dired-hide-details-mode)
  :config
  (setq dired-recursive-deletes 'always
        dired-kill-when-opening-new-dired-buffer t
        dired-dwim-target t
        dired-auto-revert-buffer #'dired-directory-changed-p
        dired-make-directory-clickable t
        dired-free-space nil
        dired-mouse-drag-files t))

(use-package dired-open
  :ensure t)

(use-package dired-rainbow
  :ensure t)
#+end_src
*** The =Dired= section for keybindings
:PROPERTIES:
:CUSTOM_ID: h:42474C8C-AAFC-4357-85BA-51D21EF7D04F
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-dired.el")
(use-package dired
  :ensure nil
  :bind
  ("C-c d" . dired-jump)
  (:map dired-mode-map
        ("o" . dired-open-xdg)))
#+end_src
*** The =Dired= section for opening files externally
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-dired.el")
(use-package dired
  :ensure nil
  :config
  (setq dired-guess-shell-alist-user
        '(("\\.\\(mp[34]\\|m4a\\|ogg\\|flac\\|webm\\|mkv\\)" "mpv" "xdg-open")
          ("\\.\\(png\\|jpe?g\\|tiff\\)" "feh" "xdg-open")
          (".*" "xdg-open"))))
#+end_src
*** The =Dired= section for opening external drives 
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-dired.el")
(defvar kam-automount-directory (format "/run/media/%s" user-login-name)
  "Directory under which drives are automounted.")

(defun kam-automount-open-in-dired ()
  "Open the automounted drive in `Dired'.
If there is more than one, let the user choose."
  (interactive)
  (let ((dirs (directory-files kam-automount-directory nil "^[^.]")))
    (dired (file-name-concat
            kam-automount-directory
            (cond ((null dirs)
                   (error "No drives mounted"))
                  ((= (length dirs) 1)
                   (car dirs))
                  (t
                   (completing-read "Open in Dired: " dirs nil t)))))))
#+end_src
*** The =Dired= section that loads =dired-x= and =dired-aux=
:PROPERTIES:
:CUSTOM_ID: h:A410CEC2-D906-483B-8BF0-CAC5BEA723AA
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-dired.el")
(use-package dired-x
  :ensure nil
  :after dired
  :config
  (setq dired-clean-up-buffers-too t
        dired-clean-confirm-killing-deleted-buffers t))

(use-package dired-aux
  :ensure nil
  :after dired
  :config
  (setq dired-isearch-filenames 'dwim
        dired-create-destination-dirs 'ask
        dired-do-revert-buffer (lambda (dir) (not (file-remote-p dir)))
        dired-create-destination-dirs-on-trailing-dirsep t))
#+end_src
*** The =Dired= section for =wdired=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-dired.el")
(use-package wdired
  :ensure nil
  :config
  (setq wdired-allow-to-change-permissions t
        wdired-create-parent-directories t))
#+end_src
*** The =Dired= section for =dired-subtree=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-dired.el")
(use-package dired-subtree
  :ensure t
  :after dired
  :bind
  (:map dired-mode-map
        ("<tab>" . dired-subtree-toggle)
        ("TAB" . dired-subtree-toggle)
        ("C-<tab>" . kam-dired-subtree-up-toggle))
  :config
  (defun kam-dired-subtree-up-toggle ()
    "Goes to the parent subtree and toggles the visiblity of it."
    (interactive)
    (dired-subtree-up)
    (dired-subtree-toggle)))
#+end_src
*** The =Dired= section for =dired-preview=
#+begin_src emacs-lisp (concat user-emacs-directory "lisp/kam-dired.el")
(use-package dired-preview
  :ensure t
  :hook (after-init . dired-preview-global-mode)
  :config
  (setq dired-preview-max-size (* (expt 2 20) 10)
        dired-preview-delay 0.15))
#+end_src
*** The =Dired= section for =image-dired=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory  "lisp/kam-dired.el")
(use-package image-dired
  :ensure nil
  :commands (image-dired)
  :bind
  (:map image-dired-thumbnail-mode-map
        ("<return>" . image-dired-thumbnail-display-external))
  :config
  (setq image-dired-thumbnail-storage 'standard
        image-dired-thumbnail-external-viewer "xdg-open"
        image-dired-thumb-size 80
        image-dired-thumb-margin 2
        image-dired-thumb-relief 0
        image-dired-thumbs-per-row 4))
#+end_src
*** The =Dired= section for =ready-player=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-dired.el")
(use-package ready-player
  :ensure t
  :mode
  ("\\.\\(mp3\\|m4a\\|mp4\\mkv\\|webm\\)\\'" . ready-player-major-mode)
  :config
  (setq ready-player-auto-play nil
        ready-player-repeat nil))
#+end_src
*** The =Dired= section for =trashed.el=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-dired.el")
(use-package trashed
  :ensure t
  :commands (trashed)
  :config
  (setq trashed-action-confirmer 'y-or-n-p
        trashed-use-header-line t
        trashed-sort-key '("Date deleted" . t)))
#+end_src
*** The =Dired= section for loading =Mac= specific settings
:PROPERTIES:
:CUSTOM_ID: h:09323889-FEF2-4F46-A532-3BA66DBFBE2E
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-dired.el")
(use-package dired
  :ensure nil
  :if (eq system-type 'darwin)
  :config
  (setq dired-use-ls-dired t
        insert-directory-program "/opt/homebrew/bin/gls"
        dired-listing-switches "-AGFhlv --group-directories-first"))
#+end_src
*** The =Dired= section that contains custom lisp
:PROPERTIES:
:CUSTOM_ID: h:8AF8A2E1-12BD-4F53-805D-6D3A22CD81ED
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-dired.el")
(defun kam-dired-shell-command-on-file-at-point ()
  "Runs a shell command on the file at point."
  (interactive)
  (concat
   (read-shell-command "Shell command: ")
   " "
   (dired-file-name-at-point)))
#+end_src
*** The call to provide =Dired=
:PROPERTIES:
:CUSTOM_ID: h:7861C98E-7CC7-4D49-ADDC-687175A2D64F
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-dired.el")
(provide 'kam-dired)
#+end_src
** The =Magit= module
:PROPERTIES:
:CUSTOM_ID: h:DB874FA0-F55B-4310-8D1A-0DA070D4FBC6
:END:
*** The =Magit= section that initializes =Magit=
:PROPERTIES:
:CUSTOM_ID: h:220E9447-2FE5-45ED-BCDC-CEFB8AF0E9B6
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-magit.el") :mkdirp yes
(use-package magit
  :ensure t
  :init
  (setq magit-define-global-key-bindings nil)
  :bind
  ("C-c g" . magit-status)
  (:map magit-section-mode-map
        ("C-<tab>" . kam-magit-toggle-parent-section))
  :config
  (setq magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1
        magit-bury-buffer-function 'magit-restore-window-configuration)
  (defun kam-magit-toggle-parent-section ()
    "Toggles the parent section header."
    (interactive)
    (magit-section-up)
    (magit-section-hide-children (magit-section-at))))
#+end_src
*** The call to provide =Magit=
:PROPERTIES:
:CUSTOM_ID: h:5392FD8F-0D8E-45AB-85D7-74EAA048C817
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-magit.el")
(provide 'kam-magit)
#+end_src
** The =Org= module
:PROPERTIES:
:CUSTOM_ID: h:EE4EAA46-7B24-4A59-96DF-A1570C3E8B21
:END:
This module contains all the settings and configuration related to =Org= and all of the software that comes with it.

=Org= is the killer feature of this configuration, and most of my time with Emacs so far has been in =Org-mode=. =Org= has a number of features that are really cool such as:

- Cycle the visibility of heading and subheadings.
- Mix prose and code in the same document. You can do this to either to make a whole program or to evaluate some snippets like in a programming notebook. See [[#h:468149A3-9868-47AD-83FE-C0A67D664B20][The =Org= section that sets up =Org Babel=.]]
- Export =Org= documents to a variety of different formats, like HTML, PDF, Markdown.
- Manage TODO lists.
- Use LaTeX inside of =Org= files to produce technical documents without having to write all of the markup.
- Quickly shift a /thing/ up and down in a document.
- Capture data or fleeting thoughts efficiently. See [[#h:3AECA5FA-E8C8-42BB-8673-D37771491AF4][The =Org= section that enables =Org Capture=.]]
- Maintain an agenda. See [[#h:EDEF7F9E-0EA7-4CEA-8F54-E54FCF880B6E][The =Org= section that enables =Org Agenda.=]]
- Clock in and out of tasks, enabling you to keep track of your time.
- Links to files regardless of file type. See [[#h:268257D7-80D5-4588-9BAF-8D5C6A8F0CB0][The =Org= section for =Org= link settings]]
  
*** The =Org= section for basic settings
:PROPERTIES:
:CUSTOM_ID: h:31F7379A-6E8A-4BC7-A1D6-FF3604904994
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-org.el") :mkdirp yes
(use-package org
  :ensure nil
  :config
  (setq org-auto-align-tags nil
        org-directory "~/Documents/"
        org-tags-column 0
        org-catch-invisible-edits 'show-and-error
        org-startup-indented t
        org-insert-heading-respect-content t
        org-special-ctrl-a/e t
        org-indirect-buffer-display 'other-window
        org-use-fast-todo-selection t
        org-enforce-todo-dependencies t
        org-return-follows-link t
        org-cycle-separator-lines 2
        org-use-speed-commands t
        org-hide-macro-markers t
        org-blank-before-new-entry '((heading . nil)
                                     (plain-list-item . auto))
        org-ellipsis " "
        org-hide-emphasis-markers t
        org-fold-catch-invisible-edits 'show
        org-fontify-todo-headline t))
#+end_src
*** The =Org= section that configures =Org Capture=
:PROPERTIES:
:CUSTOM_ID: h:3AECA5FA-E8C8-42BB-8673-D37771491AF4
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-org.el")
(use-package org
  :ensure nil
  :bind
  ("C-c c" . org-capture)
  :config
  (setq org-capture-templates
        '(("t" "Task" entry (file kam-task-inbox-file)
           "* TODO %?")
          ("p" "Project" entry )
          ("w" "Writing" entry (file+headline kam-task-task-file "Writing") "* TODO %?\n")
          ("d" "Default" entry (file "~/Documents/Inbox/inbox.org")))))

(add-hook 'olivetti-mode 'org-capture)
#+end_src
*** The =Org= section that configures =Org Refile=
:PROPERTIES:
:CUSTOM_ID: h:2B79A9C5-4C82-438A-BFA2-79BAEC7DADCC
:STYLE:    test
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-org.el")
(setq org-refile-use-outline-path t
      org-outline-path-complete-in-steps t)

(defun kam-org-refile-to-current-file ()
  "Refile the heading under the point to a heading in the current file only."
  (interactive)
  (let ((org-refile-targets '((nil . (:maxlevel . 3)))))
    (org-refile)))
#+end_src
*** The =Org= section that configures =Org Links=
:PROPERTIES:
:CUSTOM_ID: h:268257D7-80D5-4588-9BAF-8D5C6A8F0CB0
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-org.el")
(use-package org
  :ensure nil
  :bind
  ("C-c l" .  org-store-link)
  :config
  (setq org-link-context-for-files t
        org-link-keep-stored-after-insertion nil
        org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id
        org-link-frame-setup '((vm . vm-visit-folder-other-frame)
                               (vm-imap . vm-visit-imap-folder-other-frame)
                               (gnus . org-gnus-no-new-news)
                               (file . find-file)
                               (wl . wl-other-frame)))

  (defun kam-org-insert-last-stored-link-with-prompt ()
    "Inserts the last stored link in `org-stored-links' while prompting for the description of the link."
    (interactive)
    (let ((links (copy-sequence org-stored-links)))
      (if (null org-stored-links)
          (user-error "No links to insert")
        (setq l (pop links))
        (org-insert-link nil (car l) (read-from-minibuffer "Link Text: "))))))
#+end_src
*** The =Org= section that configures =Org Babel=
:PROPERTIES:
:CUSTOM_ID: h:468149A3-9868-47AD-83FE-C0A67D664B20
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-org.el")
(use-package org-babel
  :no-require
  :ensure nil
  :config
  (setq org-confirm-babel-evaluate nil
        org-src-window-setup 'current-window
        org-edit-src-persistent-message nil
        org-src-fontify-natively t
        org-src-preserve-indentation t
        org-src-tab-acts-natively t
        org-edit-src-content-indentation 0)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((C . t)
     (emacs-lisp . t))))

(use-package org-tempo
  :ensure nil
  :after (org modus-themes)
  :config
  (setq org-structure-template-alist
        '(("c" . "comment")
          ("C" . "src C :main no")
          ("e" . "src emacs-lisp")
          ("E" . "src emacs-lisp :results value code lexical:t")
          ("et" . "src emacs-lisp :tangle")
          ("s" . "src")
          ("t" . "tip")
          ("T" . "src emacs-lisp :tangle FILENAME :mkdirp yes")
          ("w" . "warning")
          ("q" . "quote"))))
#+end_src

#+RESULTS:
: t
*** The =Org= section that configures =Org Export=
:PROPERTIES:
:CUSTOM_ID: h:272DB923-1673-4B0C-AFEC-73EA28D00467
:END:
*** The =Org= section that configures =Org Attach= 
:PROPERTIES:
:CUSTOM_ID: h:C083C5B7-0EB9-4696-BEB0-4173040C1E8D
:END:
*** The =Org= section that configures =Org Protocol= 
:PROPERTIES:
:CUSTOM_ID: h:84FBE031-EE1F-4843-B3B4-27C7EDA2AAD2
:END:
*** The =Org= section that configures =Org Time Logging=
:PROPERTIES:
:CUSTOM_ID: h:1F227018-1391-4386-842A-2E9C9AAD2D7C
:END:
*** The =Org= section that configures =Org= extensions
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-org.el")
(use-package org-download
  :ensure t
  :after org)

(use-package ob-mermaid
  :ensure t
  :after org)
#+end_src
*** The =Org= section for modifying the syntax table
:PROPERTIES:
:CUSTOM_ID: h:9FBB7D12-610C-4449-B147-61B66B970ACC
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-org.el")
(defun kam-org-syntax-table-modify ()
  "Modify `org-mode-syntax-table' for the current Org buffer.

This stops the mismatch parenthesis bug in Org source blocks."
  (modify-syntax-entry ?< "." org-mode-syntax-table)
  (modify-syntax-entry ?> "." org-mode-syntax-table))

(add-hook 'org-mode-hook #'kam-org-syntax-table-modify)
#+end_src
*** The =Org= section that sets up keybindings
:PROPERTIES:
:CUSTOM_ID: h:407C8921-23EF-4911-969C-B1E6EE828405
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-org.el")

#+end_src
*** The =Org= section that prettifies Org
:PROPERTIES:
:CUSTOM_ID: h:C0BADBF4-F85F-41B4-B375-31D7248ADAC4
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-org.el")
(use-package org-modern
  :ensure t
  :after org
  :config
  (setq org-modern-star 'replace)
  (set-face-attribute 'org-modern-symbol nil :family "SF Mono")
  (global-org-modern-mode))

(use-package org
  :ensure nil
  :hook ((org-mode . olivetti-mode)
         (org-mode . visual-line-mode))
  :config
  (setq org-pretty-entities t))

#+end_src
*** The =Org= section that configures =Pomodoros=
:PROPERTIES:
:CUSTOM_ID: h:E527460D-12BC-444E-A111-D64A5B958AEF
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-org.el")
; (use-package tmr
 ; :ensure t)
#+end_src
*** The =Org= section that sets up =toc-org=
:PROPERTIES:
:CUSTOM_ID: h:BADF4859-DC2A-44D0-A8BE-C374BD29E494
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-org.el")
(use-package toc-org
  :commands toc-org-enable
  :init (add-hook 'org-mode-hook 'toc-org-enable))
#+end_src
*** The =Org= section that installs =Org-plus-contrib=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-org.el")
;; (use-package org-plus-contrib
;;   :ensure t)
#+end_src
*** The =Org= section that contains custom lisp
:PROPERTIES:
:CUSTOM_ID: h:15B7C4B7-8411-405D-BAD1-4B56C20A4CB0
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-org.el")
(defun kam-org-up-heading ()
  "Go up to the nearest heading, or to a higher level heading.
If not on a heading, finds the next heading backwards. If already on a heading, goes up higher in the tree."
  (interactive)
  (if (org-at-heading-p)
      (org-up-element)
    (org-previous-visible-heading 1)))

(defun kam-org-metadown (&optional arg)
  "Go down to the nearest heading"
  (interactive "p")
  (org-next-visible-heading arg))

(defun kam-org-insert-super-heading (arg)
  (interactive "P")
  (org-insert-heading arg)
  (cond
   ((org-at-heading-p) (org-promote))
   ((org-at-item-p) (org-indent-item))))

(defun kam-org-archive-done-tasks ()
  (interactive)
  (org-map-entries
   (lambda ()
     (org-archive-subtree)
     (setq org-map-continue-from (org-element-property :begin (org-element-at-point))))
   "/DONE" 'file))

(defun kam-org--id-get ()
  "Get the CUSTOM_ID of the current entry.
If the entry has a CUSTOM_ID, return it as is, else create a new one."
  (let* ((pos (point))
         (id (org-entry-get pos "CUSTOM_ID")))
    (if (and id (stringp id) (string-match-p "\\S-" id))
        id
      (setq id (org-id-new "h"))
      (org-entry-put pos "CUSTOM_ID" id)
      id)))

(declare-function org-map-entries "org")

(defun kam-org-promote-subtrees ()
  "Promote the subtree and all subtrees under it at point."
  (interactive)
  (org-map-entries
   (org-promote-subtree)
   nil
   'tree))

(defun kam-org-demote-subtrees ()
  "Demote the subtree and all subtrees at point."
  (interactive)
  (org-map-entries
   (org-demote-subtree)
   nil
   'tree))

;;;###autoload
(defun kam-org-id-headlines ()
  "Add missing CUSTOM_ID to all headlines in the current file."
  (interactive)
  (org-map-entries
   (lambda () (kam-org--id-get))))

;;;###autoload
(defun kam-org-id-headline ()
  "Add missing CUSTOM_ID to headline at point."
  (interactive)
  (kam-org--id-get))

(defun kam-org-insert-date-range ()
  (interactive)
  (org-time-stamp nil)
  (insert "--")
  (org-time-stamp nil))

(defun kam-org-control-metaup (&optional arg)
  (interactive "p")
  (if (org-at-heading-p)
      (org-metaup arg)
    (backward-up-list arg)))

(defun kam-org-control-metadown (&optional arg)
  (interactive "p")
  (if (org-at-heading-p)
      (org-metadown arg)
    (down-list arg)))

(defun kam-org-fold-nearest-heading (&optional arg)
  "Fold the nearest heading at point."
  (interactive)
  (kam-org-up-heading)
  (org-cycle))

(defvar kam-org-refile-region-format "\n\n%s")

(defvar kam-org-refile-region-position 'bottom
  "Where to refile a region. Use 'top to refile the region at the beginning of the subtree.")
;; this is an abomination
(defun kam-org-refile-region (beg end copy)
  "Refile the active region.
If no region is active, refile the current paragraph.
With prefix arg C-u, copy region instead of killing it."
  (interactive "r\nP")
  (unless (use-region-p)
    (setq beg (save-excursion
                (backward-paragraph)
                (skip-chars-forward "\n\t ")
                (point))
          end (save-excursion
                (forward-paragraph)
                (skip-chars-forward "\n\t ")
                (point))))
  (let* ((org-refile-headings '((nil . (:maxlevel . 10))))
         (text (buffer-substring-no-properties beg end))
         (text-length (- end beg))
         (target (save-excursion (org-refile-get-location nil nil t)))
         (heading (nth 0 target))
         (file (nth 1 target))
         (pos (nth 3 target)))
    (when (string-match "[0-9a-z]$" heading)
      (setq beg (+
                 (length (car (last (split-string heading "/"))))
                 beg
                 5) ;; value of newlines and stuff like that
            end (+
                 (length (car (last (split-string heading "/"))))
                 end
                 5)))
    (unless copy (kill-region beg end))
    (deactivate-mark)
    (with-current-buffer (find-file-noselect file)
      (save-excursion
        (goto-char pos)
        (if (eql kam-org-refile-region-position 'bottom)
            (org-end-of-subtree)
          (org-end-of-meta-data-and-drawers))
        (insert (format kam-org-refile-region-format text))))))
#+end_src
*** The call to provide =Org=
:PROPERTIES:
:CUSTOM_ID: h:4AA20E95-0CF6-47B8-BCFB-13402E6111A6
:END: 
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-org.el")
(provide 'kam-org)
#+end_src 
** The =Programming= module
:PROPERTIES:
:CUSTOM_ID: h:60A610DE-CB69-4EDD-9371-057095DA9EC7
:END:
*** The =Programming= section that configures =Flycheck=
:PROPERTIES:
:CUSTOM_ID: h:ADF0F138-BB8C-4F12-8497-F3DC450D2540
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-programming.el") :mkdirp yes
(use-package flycheck
  :ensure t
  :preface
  (defun flycheck-eldoc (callback &rest _ignored)
    "Print flycheck messages at point by calling CALLBACK."
    (when-let ((flycheck-errors (and flycheck-mode (flycheck-overlay-errors-at (point)))))
      (mapc
       (lambda (err)
         (funcall callback
                  (format "%s: %s"
                          (let ((level (flycheck-error-level err)))
                            (pcase level
                              ('info (propertize "I" 'face 'flycheck-error-list-info))
                              ('error (propertize "E" 'face 'flycheck-error-list-error))
                              ('warning (propertize "W" 'face 'flycheck-error-list-warning))
                              (_ level)))
                          (flycheck-error-message err))
                  :thing (or (flycheck-error-id err)
                             (flycheck-error-group err))
                  :face 'font-lock-doc-face))
       flycheck-errors)))

  (defun flycheck-prefer-eldoc ()
    (add-hook 'eldoc-documentation-functions #'flycheck-eldoc nil t)
    (setq eldoc-documentation-strategy 'eldoc-documentation-compose-eagerly)
    (setq flycheck-display-errors-function nil)
    (setq flycheck-help-echo-function nil))

  :hook
  ((flycheck-mode . flycheck-prefer-eldoc))
  :config
  (global-flycheck-mode 1))
#+end_src
*** The =Programming= section that integrates =Eglot= and =Eldoc=
:PROPERTIES:
:CUSTOM_ID: h:AF0DCA87-D5FB-4F14-B446-E4698E1799A1
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-programming.el")
(defun eglot-eldoc ()
  (setq eldoc-documentation-strategy
        'eldoc-documentation-compose-eagerly))

(add-hook 'eglot-managed-mode-hook 'eglot-eldoc)
#+end_src
*** The =Programming= section that configures =tree-sitter=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-programming.el")
(use-package treesit-auto
  :ensure t
  :custom
  (treesit-auto-install 'prompt)
  :config
  (treesit-auto-add-to-auto-mode-alist 'all)
  (global-treesit-auto-mode))
#+end_src
*** The =Programming= section that sets up =emacs-direnv=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-programming.el")
(use-package direnv
  :ensure t
  :config
  (direnv-mode))
#+end_src
*** The =Programming= section that sets up =envrc=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-programming.el")
(use-package envrc
  :hook (after-init . envrc-global-mode))
#+end_src
*** The =Programming= section that adjusts =compilation-mode=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-programming.el")
(use-package compile
  :ensure nil
  :hook (compilation-filter . ansi-color-compilation-filter)
  :config
  (setq compilation-always-kill t
        compilation-ask-about-save nil
        compilation-scroll-output 'first-error))

(defadvice compile (before ad-compile-smart activate)
  "Advises `compile' so it sets the argument COMINT to t."
  (ad-set-arg 1 t))
#+end_src
*** The =Programming= section that installs =terraform-mode=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-programming.el")
(use-package terraform-mode
  :ensure t)
#+end_src
*** The =Programming= section that configures =ediff=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-programming.el")
(setq ediff-keep-variants nil
      ediff-make-buffers-readonly-at-startup nil
      ediff-merge-revisions-with-ancestor t
      ediff-show-clashes-only t
      ediff-split-window-function 'split-window-horizontally
      ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src
*** The call to provide the =Programming= module
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-programming.el")
(provide 'kam-programming)
#+end_src
** The =Project= module
:PROPERTIES:
:CUSTOM_ID: h:EB91BC1F-508B-4811-9713-F14780B27EA9
:END:
*** The =Project= module that sets up =Perspective=
:PROPERTIES:
:CUSTOM_ID: h:3ACA3715-B24A-4537-8BEC-D9A637E2FA01
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-project.el")
;; (use-package perspective
;;   :ensure t
;;   :hook ((kill-emacs . persp-state-save)
;;          (emacs-startup . (lambda () (persp-state-load persp-state-default-file))))
;;   :custom
;;   (persp-mode-prefix-key (kbd "C-c x"))
;;   :bind
;;   ("C-x C-b" . persp-ibuffer)
;;   ("C-x k" . persp-kill-buffer*)
;;   ("C-c s" . persp-switch)
;;   :config
;;   (setq persp-state-default-file (concat user-emacs-directory "persp-state-save")
;;         persp-sort 'access
;;         persp-modestring-short t)
;;   (add-to-list 'consult-buffer-sources persp-consult-source)
;;   (add-hook 'ibuffer-hook
;;             (lambda ()
;;               (persp-ibuffer-set-filter-groups)
;;               (unless (eq ibuffer-sorting-mode 'alphabetic)
;;                 (ibuffer-do-sort-by-alphabetic))))

;;   (persp-mode))
#+end_src
*** The call to provide =Project=
:PROPERTIES:
:CUSTOM_ID: h:0A33B244-86E9-42F0-8E3A-CFC1BA61416D
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-project.el")
(provide 'kam-project)
#+end_src
** The =Task= module
*** Use Case
*** The =Task= module that creates custom lisp
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-task.el") :mkdirp yes
(defvar kam-task-projects-directory "~/Documents/Projects/"
  "The default directory where project folders are stored.")

(defvar kam-task-task-file "~/Documents/Inbox/tasks.org"
  "The default file where all of my tasks and projects are stored.")

(defvar kam-task-inbox-file "~/Documents/Inbox/inbox.org"
  "The default file where all of my projects and todos are stored before they are sorted.")

(defun kam-task-create-project ()
  "Create a project in the `kam-task-projects-directory'."
  (interactive)
  (let* ((default-directory kam-task-projects-directory)
         (new-project (read-directory-name "Project: ")))
    (make-directory (concat kam-task-projects-directory (s-replace " " "_" new-project)))
    (write-region (concat "* " new-project) nil kam-task-inbox-file 'append)))

(defun kam-task-get-projects-list ()
  "Returns all of the names of the projects in `kam-task-projects-directory' as a list."
  (seq-drop
   (directory-files kam-task-projects-directory) 2))

(use-package org
  :ensure nil
  :bind
  ("C-c a" . org-agenda)
  :config
  (setq org-agenda-files (list kam-task-task-file)
        org-agenda-custom-commands '(("z" "Things to write about"
                                      ((agenda "" ((org-agenda-files `(,kam-task-task-file))
                                                   (org-agenda-overriding-header "Things to write about")
                                                   (org-agenda-skip-function '(kam-org-agenda-skip-entry-if-property "STYLE" "test"))))))
                                     
                                     ("i" "Inbox" todo "TODO" ((org-agenda-files `(,kam-task-inbox-file))
                                                               (org-agenda-overriding-header "Unprocessed Inbox Items")))
                                     
                                     ("d" "Daily Agenda"
                                      ((agenda "" ((org-agenda-span 'day)
                                                   (org-deadline-warning-days 7)))

                                       (tags-todo "+PRIORITY=\"A\""
                                                  ((org-agenda-overriding-header "High Priority Tasks")))))
                                     ("w" "Weekly Review"
                                      ((agenda ""
                                               ((org-agenda-overriding-header "Completed Tasks")
                                                (org-agenda-skip-function '(org-agenda-skip-entry-if 'nottodo 'done))
                                                (org-agenda-span 'week)))
                                       (agenda ""
                                               ((org-agenda-overriding-header "Unfinished Scheduled Tasks")
                                                (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                                                (org-agenda-span 'week))))))
        org-agenda-hide-tags-regexp "."
        org-log-done-time 'time
        org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))

  (defun kam-task-org-agenda-refile ()
    "Refile in the `org-agenda'. Intended to only be used in the agenda."
    (interactive)
    (let (org-refile-targets `((,kam-task-task-file . (:maxlevel . 2))))
      (org-refile)))

  (defun kam-task-org-agenda-inbox ()
    "Go to your Inbox in `org-agenda'."
    (interactive)
    (org-agenda nil "i" nil))

  (defun kam-task-org-agenda-tasks ()
    "Go to your tasks in `org-agenda'."
    (interactive)
    (org-agenda nil "t" nil))

  (defun kam-task-org-agenda-skip-entry-if-property (prop val)
    "Skip the entry if it marked with PROP property with the value VAL. PROP and VAL should be a string."
    (let ((end (org-entry-end-position))
          (prop-regexp (org-re-property prop nil nil val)))
      (if (re-search-forward prop-regxep end t)
          nil
        end)))

  (add-hook 'org-agenda-after-show-hook 'visual-line-mode)

  (with-eval-after-load 'pulsar
    (dolist (hook '(org-agenda-after-show-hook org-follow-link-hook))
      (add-hook hook #'pulsar-recenter-center)
      (add-hook hook #'pulsar-reveal-entry))))

(provide 'kam-task)
#+end_src
** The =Eshell= module
:PROPERTIES:
:CUSTOM_ID: h:B2F95D9E-E719-4EDD-AC6F-F1F34EF2E556
:END:
*** Use case
*** Eshell configuration
:PROPERTIES:
:CUSTOM_ID: h:5215F24B-D6EB-43A1-9C86-D7825D8126D6
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-eshell.el") :mkdirp yes
;; -*- lexical-binding: t; -*-
(use-package eshell
  :ensure nil
  ;; :hook ((eshell-mode . #'kam-eshell--set-env)
  ;; (eshell-mode . completion-preview-mode))
  :bind
  (("C-c e" . eshell)
   :map eshell-mode-map
   ("<tab>" . completion-at-point)
   ("C-c C-d" . eshell/kam-z ))
  :config
  ;; (add-to-list 'eshell-lisp-list 'eshell-smart)
  (setq eshell-prompt-regexp "\\[[[:punct:][:alnum:]]+  [[:punct:][:alnum:]]+ \\$ ")
  (setq eshell-list-files-after-cd t
        eshell-ls-initial-args '("-AGFhlv" "--color=always")
        eshell-scroll-to-bottom-on-input 'all
        eshell-error-if-no-glob t
        eshell-hist-ignoredups t
        eshell-history-size 10000
        eshell-save-history-on-exit t
        eshell-prefer-lisp-functions nil
        eshell-destroy-buffer-when-process-dies t
        eshell-highlight-prompt t)

  (add-hook 'eshell-mode-hook (lambda () (setq outline-regexp eshell-prompt-regexp))))

(defun kam-pwd-replace-home (pwd)
  "Replace $HOME in PWD with a tilde (~) character."
  (let* ((home (expand-file-name (getenv "HOME")))
         (home-len (length home)))
    (if (and
         (>= (length pwd) home-len)
         (equal home (substring pwd 0 home-len)))
        (concat "~" (substring pwd home-len))
      pwd)))

(defun kam-pwd-shorten-dirs (pwd)
  "Shorten all directory names in PWD except the last two."
  (let ((p-lst (split-string pwd "/")))
    (if (> (length p-lst) 2)
        (concat
         (mapconcat
          (lambda (elm)
            (if (zerop (length elm)) ""
              (substring elm 0 1)))
          (butlast p-lst 2)
          "/")
         (mapconcat (lambda (elm) elm)
                    (last p-lst 2)
                    "/"))
      pwd)))

(defun kam-eshell--split-directory-prompt (directory)
  (if (string-match-p ".*/.*" directory)
      (list (file-name-directory directory) (file-name-base directory))
    (list "" directory)))

(setq eshell-prompt-function
      (lambda ()
        (let* ((pwd (eshell/pwd))
               (directory (kam-eshell--split-directory-prompt
                           (kam-pwd-shorten-dirs
                            (kam-pwd-replace-home pwd))))
               (parent (car directory))
               (dir (cadr directory)))
          (modus-themes-with-colors
            (concat
             (propertize "[" 'face `(:foreground ,fg-main :background ,bg-active))
             (propertize (user-login-name) 'face `(:foreground ,fg-main :background ,bg-active))
             (propertize "@" 'face `(:foreground ,fg-main :background ,bg-active))
             (propertize (system-name) 'face `(:foreground ,pink :background ,bg-active))
             (propertize "]" 'face `(:foreground ,fg-main :background ,bg-active))
             (propertize "  " 'face `(:foreground ,fg-main :background ,bg-active))
             (propertize parent 'face `(:foreground ,pink :weight bold))
             (propertize dir 'face `(:foreground ,pink :weight bold))
             (propertize " $ " 'face `(:weight bold :background ,bg-active)))))))

(defun kam-eshell-next-prompt (n)
  "Move to the end of the Nth next prompt in the buffer. See `eshell-prompt-regexp'."
  (interactive "p")
  (re-search-forward eshell-prompt-regexp nil t n)
  (when eshell-highlight-prompt
    (while (not (get-text-property (line-beginning-position) 'read-only))
      (re-search-forward eshell-prompt-regexp nil t n)))
  (eshell-skip-prompt))

(use-package em-smart
  :ensure nil
  :config
  (setq eshell-where-to-jump 'after
        eshell-review-quick-commands nil
        eshell-smart-space-goes-to-end t))
#+end_src
*** The =Eshell= section for custom lisp
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-eshell.el")
(defun kam-eshell--history-to-list ()
  "Returns the current Eshell buffer's history as a list of strings."
  (when (and (ring-p eshell-history-ring)
             (not (ring-empty-p eshell-history-ring)))
    (let (history)
      (dotimes (index (ring-length eshell-history-ring))
        (push (ring-ref eshell-history-ring index) history))
      (delete-dups history)
      (setq history (nreverse history))
      history)))

(defun kam-eshell--input-history-prompt ()
  "Prompt for completion against `kam-eshell-history-to-list'."
  (let* ((history (kam-eshell--history-to-list))
         (default (car history)))
    (completing-read
     (format-prompt "Insert input from history: " default)
     history
     nil
     nil
     nil
     nil
     default)))

(defun eshell/clear ()
  "Clear the Eshell buffer."
  (let ((inhibit-read-only t))
    (erase-buffer)))

(defun eshell/z (&optional regexp)
  "Navigate to a previously visited directory in Eshell, or to any directory offered by `consult-dir'."
  (interactive)
  (let ((eshell-dirs (delete-dups
                      (mapcar 'abbreviate-file-name
                              (ring-elements eshell-last-dir-ring)))))
    (cond
     ((and (not regexp) (featurep 'consult-dir)
           (let* ((consult-dir--source-eshell `(:name "Eshell"
                                                      :narrow ?e
                                                      :category file
                                                      :face consult-file
                                                      :items ,eshell-dirs))
                  (consult-dir-sources (cons consult-dir--source-eshell
                                             consult-dir-sources)))
             (eshell/cd (substring-no-properties
                         (consult-dir--pick "Switch directory: ")))))
      (t (eshell/cd (if regexp (eshell-find-previous-directory regexp)
                      (completing-read "cd: " eshell-dirs))))))))

(defun kam-eshell-here ()
  "Opens up a new shell in the directory associated with the current buffers file.
The eshell is renamed to match that directory in order to make multiple eshell windows easier."
  (interactive)
  (let* ((parent (if (buffer-file-name)
                     (file-name-directory (buffer-file-name))
                   default-directory))
         (name (car (last (split-string parent "/" t)))))
    (eshell "new")
    (rename-buffer (concat "*eshell: " name "*"))
    (insert (concat "ls"))
    (eshell-send-input)))
#+end_src
*** Useful Eshell keybindings
:PROPERTIES:
:CUSTOM_ID: h:EAA6033F-DE61-4F2D-A4CE-9AC194A06523
:END:
"C-c M-b" Inserts the printed buffer name at point
"C-c M-i" Inserts the printed process name at point
"C-c M-v" Inserts an environment variable at point
"C-c M-d" Toggles between direct input and delayed input (send on RET)
*** The call to provide =Eshell=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-eshell.el")
(provide 'kam-eshell)
#+end_src
** The =ITE= module
:PROPERTIES:
:CUSTOM_ID: h:537F628C-3766-4A29-B210-77603F2E687B
:END:
*** The =ITE= section about setting up =Org-roam=
:PROPERTIES:
:CUSTOM_ID: h:2D160116-0F36-4737-8C07-9D759105E4EA
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-ite.el") :mkdirp yes
;; -*- lexical-binding: t; -*-
(use-package org-roam
  :ensure t
  :bind
  ("C-c r c" . #'kam-org-roam-node-insert-immediate)
  ("C-c r C" . org-roam-node-insert)
  ("C-c r n" . org-roam-buffer-toggle)
  ("C-c r h" . (lambda () (interactive) (find-file "~/Documents/Resources/Zettelkasten/home.org")))
  ("C-c r i" . (lambda () (interactive) (find-file "~/Documents/Resources/Zettelkasten/inbox.org")))
  ("C-c r l" . org-roam-tag-add)
  :custom
  (org-roam-directory (file-truename "~/Documents/Resources/Zettelkasten"))
  (org-roam-completion-everywhere t)
  (org-roam-capture-templates
   '(("d" "Default" plain
      "%?"
      :if-new (file+head ",(s-replace " " "_" ${title}.org)" "#+title: ${title}\n#+filetags:\n#+date: %U\n\n\n* References:")
      :immediate-finish t
      :unnarrowed t)
     ("r" "Reference Note" plain "%?"
      :if-new
      (file+head "Reference/${title}.org" "#+title: ${title}\n#+filetags: \n#+date: %U\n")
      :immediate-finish t
      :unnarrowed t)
     ("i" "Index Note" plain "%?"
      :if-new
      (file+head "${title}.org" "#+title: ${title}\n#+filetags: :Index:\n#+date: %U\n\n\n\n* References:")
      :immediate-finish t
      :unnarrowed t)))
  :config
  (setq org-roam-node-display-template "${title:*}"
        ;; (concat "${title:*} " (propertize "${tags:*}" 'face 'org-tag))
        org-roam-extract-new-file-path "${slug.org}"
        org-roam-list-files-commands '(rg fd))
  (org-roam-db-autosync-mode)
  (setq org-roam-db-node-include-function
        (lambda ()
          (not (org-current-level))))
  (require 'org-roam-protocol) 
  (org-roam-setup))

(add-hook 'org-roam-mode-hook #'turn-on-visual-line-mode)
(add-hook 'org-roam-mode-hook #'variable-pitch-mode)

(use-package consult-org-roam
  :ensure t
  :after org-roam
  :bind
  (("C-c r d" . consult-org-roam-file-find)
   ("C-c r s" . consult-org-roam-search)
   ("C-c r b" . consult-org-roam-backlinks))
  :config
  (setq consult-org-roam-grep-func #'consult-ripgrep)
  (consult-org-roam-mode 1))
#+end_src
*** The =ITE= section that sets up =Org Roam UI=
:PROPERTIES:
:CUSTOM_ID: h:82022D74-0BBA-4992-BE78-37CE0FD9789C
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-ite.el")
(use-package org-roam-ui
  :ensure t
  :config
  (setq org-roam-ui-sync-theme t)
  (setq org-roam-ui-follow t)
  (setq org-roam-ui-update-on-save nil)
  (setq org-roam-ui-open-on-start t))
#+end_src
*** The =ITE= section for =Org Anki=
:PROPERTIES:
:CUSTOM_ID: h:314CF099-B35A-498E-AFC0-D4E89AB3E80C
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-ite.el")
(use-package org-anki
  :ensure t
  :config
  (setq org-anki-api-key nil
        org-anki-default-deck "get that main main"))
#+end_src
***  The =ITE= section for =Org QL=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-ite.el")
(use-package org-ql
  :ensure t)
#+end_src
*** The =ITE= section that contains custom lisp
:PROPERTIES:
:CUSTOM_ID: h:423D93FE-5D46-4892-86DB-F7A6B564EB05
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-ite.el")
(defun kam-search-zettelkasten ()
  (interactive)
  (let ((consult-ripgrep-command "rg --null --ignore-case --type org --line-number . --color always --max-columns 500 --no-heading -e ARG OPTS")
       (dirs (list "~/Documents/Resources/Zettelkasten")))
    (consult-ripgrep dirs)))

(defun kam-search-literature-notes ()
  "Searches through recorded literature notes."
  (interactive)
  (let ((consult-ripgrep-command "rg --null --ignore-case --type org --line-number . --color always --max-columns 500 --no-heading -e ARG OPTS")
       (dirs (list "~/Documents/Resources/Reference Notes")))
    (consult-ripgrep dirs)))

(defun kam-org-roam-node-insert-immediate (arg &rest args)
  (interactive "P")
  (let ((args (cons arg args))
        (org-roam-node-capture-templates (list (append (car org-roam-capture-templates)
                                                       '(:immediate-finish t)))))
    (apply #'org-roam-node-insert args)))

(defun kam-org-roam-filter-by-tag (tag-name)
  (lambda (node)
    (member tag-name (org-roam-node-tags node))))

(defun kam-org-roam-find-notes-by-tag ()
  "List all notes of a given tag, selected by minibuffer completion."
  (interactive)
  (org-roam-node-find nil nil
                      (kam-org-roam-filter-by-tag
                       (completing-read "Select tag: " (org-roam-tag-completions)))))

(defun kam-org-roam-find-index-notes ()
  "Finds the nodes in the Zettelkasten with the tag Index."
  (interactive)
  (org-roam-node-find nil nil
                      (kam-org-roam-filter-by-tag "Index")))

(defun kam-org-roam-find-baby-notes ()
  "Finds the nodes in the Zettelkasten with the tag Baby."
  (interactive)
  (org-roam-node-find nil nil
                      (kam-org-roam-filter-by-tag "Baby")))
#+end_src
*** The call to provide =ITE=
:PROPERTIES:
:CUSTOM_ID: h:62D42F86-9152-416B-9E29-C011AFCF969A
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-ite.el")
(provide 'kam-ite)
#+end_src
** The =Term= module
*** Purpose
This module is designed to make a nice terminal emulator experience within Emacs.
*** The =Term= section that sets up =EAT=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-term.el") :mkdirp t
; (use-package eat
;  :ensure t
;  :config
;  (setq eat-shell (getenv "SHELL"))
;  (add-hook 'eshell-load-hook #'eat-eshell-mode)
 ; (add-hook 'eshell-load-hook #'eat-eshell-visual-command-mode))
#+end_src
*** The =Term= section that sets up =Vterm=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-term.el")
(use-package vterm
  :ensure t
  :bind
  (:map vterm-mode-map
   ("<C-backspace>" . (lambda () (interactive) (vterm-send-key (kbd "C-w"))))
   ("<f6>" . avy-goto-char-timer)
   ("<f7>" . ace-window)))
#+end_src
*** The call to provide =Term=
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-term.el")
(provide 'kam-term)
#+end_src
* Libraries
:PROPERTIES:
:CUSTOM_ID: h:353F263C-E6D4-4028-B295-05ACA4CF122B
:END:
** Common
=Kam-common= is a library created to house all of the custom behaviors and functions that are used throughout the configuration and other libraries.
:PROPERTIES:
:CUSTOM_ID: h:B9F8EBD6-92FE-4808-94FC-4BEE8536D690
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-common.el") :mkdirp yes
;;; -*- lexical-binding: t -*-
(eval-when-compile
  (require 'subr-x)
  (require 'cl-lib))

;;;###autoload
(defun kam-common-empty-buffer-p ()
  "Test whether the buffer is empty."
  (or (= (point-min) (point-max))
      (save-excursion
        (goto-char (point-min))
        (while (and (looking-at "^\\([a-zA-Z]+: ?\\)?$")
                    (zerop (forward-line 1))))
        (eobp))))

;;;###autoload
(defun kam-common-window-bounds ()
  "Return the start and end points of the window as a cons cell."
  (cons (window-start) (window-end)))

;;;###autoload
(defun kam-common-page-p ()
  "Return non-nil if there is a `page-delimiter' in the buffer."
  (or (save-excursion (re-search-forward page-delimiter nil t))
      (save-excursion (re-search-backward page-delimiter nil t))))

;;;###autoload
(defun kam-common-three-or-more-windows-p (&optional frame)
  "Return non-nil if three or more windows occupy FRAME.
If FRAME is non-nil, inspect the current frame."
  (>= (length (window-list frame :no-minibuffer)) 3))

;;;###autoload
(defun kam-common-two-windows-p (&optional frame)
  "Return non-nil if two windows occupy FRAME.
If FRAME is non-nil, inspect the current frame."
  (= (length (window-list frame :no-minibuffer)) 2))

;;;###autoload
(defun kam-common-read-data (file)
  "Read Elisp data from FILE."
  (with-temp-buffer
    (insert-file-contents file)
    (read (current-buffer))))

;;;###autoload
(defun kam-common-shell-command-with-exit-code-and-output (command &rest args)
  "Runs COMMAND with ARGS.
Return the exit code and output in a list."
  (with-temp-buffer
    (list (apply 'call-process command nil (current-buffer) nil args)
          (buffer-string))))

;;;###autoload
(defun kam-common-sudo-shell-command (command &rest args)
  "Runs COMMAND with ARGS as root."
  (async-shell-command (concat "echo " (read-passwd "Password: ") " | sudo -S " command)))

(advice-add 'kam-common-sudo-shell-command :after 'kam-common-clear-echo-area)

;;;###autoload
(defun kam-common-completion-category ()
  "Return completion category."
  (when-let* ((window (active-minibuffer-window)))
    (with-current-buffer (window-buffer window)
      (completion-metadata-get
       (completion-metadata (buffer-substring-no-properties
                             (minibuffer-prompt-end)
                             (max (minibuffer-prompt-end) (point)))
                            minibuffer-completion-table
                            minibuffer-completion-predicate)
       'category))))

;;;###autoload
(defun kam-common-completion-table (category candidates)
  "Pass appropriate metadata CATEGORY to completion CANDIDATES.

This is intended for bespoke functions that can then be parsed by other tools."
  (lambda (string pred action)
    (if (eq action 'metadata)
        `(metadata (category . ,category))
      (complete-with-action action candidates string pred))))

;;;###autoload
(defun kam--duplicate-buffer-substring (boundaries)
  "Duplicate buffer substring between BOUNDARIES.
BOUNDARIES is a cons cell representing buffer positions."
  (unless (consp boundaries)
    (error "`%s' is not a cons cell" boundaries))
  (let ((beg (car boundaries))
        (end
         (cdr boundaries)))
    (goto-char end)
    (newline)
    (insert (buffer-substring-no-properties beg end))))

(defun kam-completing-read (prompt collection &optional predicate require-match initial-input hist def inherit-input-method)
  "Calls `completing-read' but returns the value from COLLECTION.

Simple wrapper around the `completing-read' function that assumes the collection is either an alist or a hashtable, and returns the _value_ of the choice, not the selected choice.

An example function would look like:
(defun kam-test-function (selection)
  (interactive (list (kam-completing-read \"Prompt: \" kam-test)))
  (message \"%s\" selection))

Where kam-test is an alist of choices mapped to values."

  (cl-flet ((assoc-list-p (obj) (and (listp obj) (consp (car obj)))))
    (let* ((choice
            (completing-read prompt collection predicate require-match initial-input hist def inherit-input-method))
           (results (cond
                     ((hash-table-p collection) (gethash choice collection))
                     ((assoc-list-p collection) (alist-get choice collection def nil 'equal))
                     (t choice))))
      (if (listp results) (first results) results))))

(defun kam-common-rename-file-and-buffer (name)
  "Apply NAME to current file and rename its buffer."
  (interactive
   (list (read-string "Rename current file: " (buffer-file-name))))
  (let ((file (buffer-file-name)))
    (if (vc-registered file)
        (vc-rename-file file name))
    (set-visited-file-name name t t)))

(defun kam-common-parse-file-as-list (file)
  "Return the contents of FILE as a list of strings.
Strings are split at the newline characters then trimmed for negative space."
  (split-string
   (with-temp-buffer
     (insert-file-contents file)
     (buffer-substring-no-properties (point-min) (point-max)))
   "\n" :omit-nulls "[\s\f\t\n\r\v]+"))

;;;###autoload
(defun kam-common-ignore (&rest _)
  "Use this as a wrapper on a function to make it do nothing."
  nil)

;;;###autoload
(defun kam-common-window-narrow-p ()
  "Return non-nil if the window is narrow.
Check if the `window-width' is less than `split-width-threshold'."
  (and (numberp split-width-threshold)
       (< (window-total-width) split-width-threshold)))

;;;###autoload
(defun kam-common-window-small-p ()
  "Return non-nil if the window is small.
Check if the `window-width' or the `window-height' is less than `split-width-threshold' or `split-height-threshold', respectively."
  (or (and (numberp split-width-threshold)
           (< (window-total-width) split-width-threshold))
      (and (numberp split-height-threshold)
           (> (window-total-height) split-height-threshold))))

;;;###autoload
(defun kam-common-crm-exclude-selected-p (input)
  "Filter out INPUT from `completing-read-multiple'.
Hide non-destructively the selected entries from completion table, avoiding the risk of entering the same match twice.

Use as the PREDICATE of `completing-read-multiple'."
  (if-let* ((pos (string-match-p crm-separator input))
            (rev-input (reverse input))
            (element (reverse
                      (substring rev-input 0
                                 (string-match-p crm-separator rev-input))))
            (flag t))
      (progn
        (while pos
          (if (string= (substring input 0 pos) element)
              (setq pos nil)
            (setq input (substring input (1+ pos))
                  pos (string-match-p crm-separator input)
                  flag (when pos t))))
        (not flag))
    t))

;;;###autoload
(defun kam-common-active-minor-modes ()
  "Returns list of active minor modes for the current buffer."
  (let ((active-modes))
    (mapc (lambda (m)
            (when (and (boundp m) (symbol-value m))
              (push m active-modes)))
          minor-mode-list)
    active-modes))

;;;###autoload
(defun kam-common-clear-echo-area (&rest _nil)
  "Clear the echo area.
Use this as advice :after a noisy function."
  (message ""))

(defun kam-common-first-char (str)
  "Return the first character from STR."
  (substring str 0 1))

(provide 'kam-common)
#+end_src
** Consult
This library is dedicated to creating custom commands and behaviors for the =Consult= package. The configuration for Consult can be found [[#h:FC68FE2E-E1DF-4206-AB94-A89F62D9C09F][here]].
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-consult.el") :mkdirp yes :lexical t
(defun kam-consult-imenu--select (prompt)
  "Returns a selection from `consult-imenu'."
  (let ((items (consult-imenu--items)))
    (consult-imenu--deduplicate items)
    (consult--read
     (or items (user-error "Imenu is empty"))
     :state
     (let* ((preview (consult--jump-preview)))
       `(lambda (action cand)
          (funcall ',preview action (and (markerp (cdr cand)) (cdr cand)))))
     :narrow
     (when-let (narrow (consult-imenu--narrow))
       (list :predicate
             (lambda (cand)
               (eq (get-text-property 0 'consult-type (car cand))
                   consult--narrow))
             :keys narrow))
     :group (consult-imenu--group)
     :prompt prompt
     :require-match t
     :category 'imenu
     :history 'consult-imenu--history
     :add-history 'consult-imenu--history
     :lookup #'consult--lookup-cons
     :sort nil)))

(defmacro kam-consult-imenu--action (prompt &rest body)
  "Execute forms in BODY at the location of an `consult-imenu' selection."
  `(let ((item (kam-consult-imenu--select ',prompt)))
     (pcase item
       (`(,name ,pos ,fn . ,args)
        (push-mark nil t)
        (apply fn name pos args))
       (`(,_ . ,pos)
        (save-excursion
          (consult--jump pos)
          ,@body))
       (_ (error "Unknown imenu item: %S" item)))))

(defmacro kam-consult-org-heading--action (&rest body)
  "Execute forms in BODY at the location of an `consult-org-heading' selection."
  `(let* ((headings (consult-org-heading)))
     ,@body))

(defun kam-consult-org-heading-link ()
  "Insert a link at point to the location of an Org heading using minibuffer completion."
  (interactive)
  (save-excursion
    (kam-consult-org-heading--action (org-store-link nil t)))
  (kam-org-insert-last-stored-link-with-prompt))

(defvar kam-consult--previous-point nil
  "Location of point before entering minibuffer.
Used to preselect nearest headings and imenu items.")

(defun kam-consult--set-previous-point (&optional arg1 arg2)
  "Save location of point. Used before entering the minibuffer."
  (setq kam-consult--previous-point (point)))

(advice-add #'consult-org-heading :before #'kam-consult--set-previous-point)
(advice-add #'consult-outline :before #'kam-consult--set-previous-point)

(advice-add #'vertico--update :after #'kam-consult-vertico--update-choose)

(defun kam-consult-vertico--update-choose (&rest _)
  "Pick the nearest candidate rather than the first after updating candidates."
  (when (and kam-consult--previous-point
             (memq current-minibuffer-command
                   '(consult-org-heading consult-outline)))
    (setq vertico--index
          (max 0
               (1- (or (seq-position
                        vertico--candidates
                        kam-consult--previous-point
                        (lambda (cand point-pos)
                          (> (cl-case current-minibuffer-command
                               (consult-outline
                                (car (consult--get-location cand)))
                               (consult-org-heading
                                (get-text-property 0 'consult--candidate cand)))
                             point-pos)))
                       (length vertico--candidates))))))
  (setq kam-consult--previous-point nil))

 (defcustom kam-consult-ripgrep-or-line-limit 300000
    "Buffer size threshold for `kam-consult-ripgrep-or-line'.
When the number of characters in a buffer exceeds this threshold,
`consult-ripgrep' will be used instead of `consult-line'."
    :type 'integer)

  (defun kam-consult-ripgrep-or-line ()
    "Call `consult-line' for small buffers and `consult-ripgrep' for large files."
    (interactive)
    (if (or (not buffer-file-name)
            (buffer-narrowed-p)
            (ignore-errors
              (file-remote-p buffer-file-name))
            (jka-compr-get-compression-info buffer-file-name)
            (>= (buffer-size)
                (/ kam-consult-ripgrep-or-line-limit
                   (if (eq major-mode 'org-mode) 4 1))))
        (progn
          (let ((consult)))
          (consult-line)
          (setq this-command 'consult-line))
      (when (file-writable-p buffer-file-name)
        (save-buffer))
      (let ((consult-ripgrep-args
             (concat consult-ripgrep-args
                     " -g "
                     (shell-quote-argument (file-name-nondirectory buffer-file-name))
                     " ")))
        (consult-ripgrep))))

  (defun kam-consult-line-symbol-at-point ()
    "Start a `consult-line' search with the symbol at the point."
    (interactive)
    (consult-line (thing-at-point 'symbol)))

  (defun kam-search-emacs-info-pages ()
    "Search through the Emacs info pages."
    (interactive)
    (consult-info "emacs" "efaq"))

  (defun kam-search-elisp-info-pages ()
    "Search through the Emacs Lisp pages."
    (interactive)
    (consult-info "elisp" "eintr"))

  (defun kam-search-org-info-pages ()
    "Search through the Org info pages."
    (interactive)
    (consult-info "org"))

  (defun kam-consult-find-file-with-preview (prompt &optional dir default mustmatch initial pred)
    (interactive)
    (let ((default-directory (or dir default-directory))
          (minibuffer-completing-file-name t))
      (consult--read #'read-file-name-internal
                     :state (consult--file-preview)
                     :prompt prompt
                     :initial initial
                     :require-match mustmatch
                     :predicate pred)))

  (setq read-file-name-function #'kam-consult-find-file-with-preview)
  
  (defun kam-menu ()
    "If the current buffer's major mode is Org mode, opens `consult-org-heading'. Otherwise opens `consult-imenu'."
    (interactive)
    (if (derived-mode-p 'org-mode)
        (progn
          (consult-org-heading)
          (setq this-command 'consult-org-heading))
      (consult-imenu)))

(provide 'kam-consult)
#+end_src
** Writing
The writing library is a collection of functions and behaviors which make writing more enjoyable and possible. My view on writing is based on "view". Sometimes you want to have a very narrow view, like to a particular paragraph or sentence when editing. Or sometimes you need to have a very wide view, like when you are editing the structure of a book or trying to understand the progression of a character arc across multiple chapters.
:PROPERTIES:
:CUSTOM_ID: h:F5F9BB93-D35E-4A4F-ACBF-2F05D085AC09
:END:
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-writing.el") :mkdirp yes
(defun kam-writing--get-sentence ()
  "Returns the sentence at point as a string."
  (sentence-at-point t))

(defun kam-writing--get-sentence-test ()
  "enen"
  (let (p1 p2)
    (setq p1 (progn
               (backward-sentence)
               (point)))
    (setq p2 (progn
               (forward-sentence)
               (point)))
    (cons p1 p2)))

(defun kam-writing--indirect-buffer-test ()
  "Moves the sentence into a throwaway buffer."
  (interactive)
  (let* ((sentence (kam-writing--get-sentence))
         (buffer (org-get-indirect-buffer)))
    (switch-to-buffer buffer)
    (with-current-buffer
        (rename-buffer (concat "*Indirect Buffer: " (buffer-name) "*") t)
      (insert sentence))))

(defun kam-writing-sparse-tree-and-narrow ()
  "Create a sparse tree in an indirect buffer and narrow it to the tree."
  (interactive)
  (org-tags-sparse-tree)
  (org-tree-to-indirect-buffer))

;; org-sparse-tree
;; org-tree-to-indirect-buffer

(provide 'kam-writing)
#+end_src
** Modeline
:PROPERTIES:
:ID: 90ecc2e2-ec44-444f-a373-6aca647070e7
:END:
*** Defining the faces
This library is dedicated to defining the functions needed to generate the modeline created [[id:81aad2f2-a0f6-4b9a-a657-23451985e93d][here]].
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-modeline.el") :mkdirp yes :lexical t
(require 'kam-common)

(defgroup kam-modeline nil
  "My custom modeline."
  :group 'mode-line)

(defgroup kam-modeline-faces nil
  "Faces for my custom modeline."
  :group 'kam-modeline)

(defvar kam-modeline-string-truncate-length 15
  "String length after which truncation should be done in small windows.")

(defface kam-modeline-indicator-button nil
  "Generic face for indicators that have a background.")

(defface kam-modeline-indicator-red
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#880000")
    (((class color) (min-colors 88) (background dark))
     :foreground "#ff9f9f")
    (t :foreground "red"))
  "Face for modeline indicators."
  :group 'kam-modeline-faces)

(defface kam-modeline-indicator-red-bg
  '((default :inherit (bold kam-modeline-indicator-button))
    (((class color) (min-colors 88) (background light))
     :background "#aa1111" :foreground "white")
    (((class color) (min-colors 88) (background dark))
     :background "#ff9090" :foreground "black")
    (t :background "red" :foreground "black"))
  "Face for modeline indicators with a background."
  :group 'kam-modeline-faces)

(defface kam-modeline-indicator-green
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#005f00")
    (((class color) (min-colors 88) (background dark))
     :foreground "#73fa7f")
    (t :foreground "green"))
  "Face for modeline indicators."
  :group 'kam-modeline-faces)

(defface kam-modeline-indicator-yellow
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#6f4000")
    (((class color) (min-colors 88) (background dark))
     :foreground "#f0c526")
    (t :foreground "yellow"))
  "Face for modeline indicators."
  :group 'kam-modeline-faces)

(defface kam-modeline-indicator-yellow-bg
  '((default :inherit (bold kam-modeline-indicator-button))
    (((class color) (min-colors 88) (background light))
     :background "#805000" :foreground "white")
    (((class color) (min-colors 88) (background dark))
     :background "#ffc800" :foreground "black")
    (t :background "yellow" :foreground "black"))
  "Face for modeline indicators with a background."
  :group 'kam-modeline-faces)

(defface kam-modeline-indicator-orange
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#6f4000")
    (((class color) (min-colors 88) (background dark))
     :foreground "#f0c526")
    (t :foreground "orange"))
  "Face for modeline indicators."
  :group 'kam-modeline-faces)

(defface kam-modeline-indicator-orange-bg
  '((default :inherit (bold kam-modeline-indicator-button))
    (((class color) (min-colors 88) (background light))
     :background "#FFBF00" :foreground "white")
    (((class color) (min-colors 88) (background dark))
     :background "#FFBF00" :foreground "black")
    (t :background "orange" :foreground "black"))
  "Face for modeline indicators with a background."
  :group 'kam-modeline-faces)

(defface kam-modeline-indicator-blue
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#00228a")
    (((class color) (min-colors 88) (background dark))
     :foreground "#88bfff")
    (t :foreground "blue"))
  "Face for modeline indicators."
  :group 'kam-modeline-faces)

(defface kam-modeline-indicator-blue-bg
  '((default :inherit (bold kam-modeline-indicator-button))
    (((class color) (min-colors 88) (background light))
     :background "#0000aa" :foreground "white")
    (((class color) (min-colors 88) (background dark))
     :background "#77aaff" :foreground "black")
    (t :background "blue" :foreground "black"))
  "Face for modeline indicators with a background."
  :group 'kam-modeline-faces)

(defface kam-modeline-indicator-magenta
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#6a1aaf")
    (((class color) (min-colors 88) (background dark))
     :foreground "#e0a0ff")
    (t :foreground "magenta"))
  "Face for modeline indicators."
  :group 'kam-modeline-faces)

(defface kam-modeline-indicator-magenta-bg
  '((default :inherit (bold kam-modeline-indicator-button))
    (((class color) (min-colors 88) (background light))
     :background "#6f0f9f" :foreground "white")
    (((class color) (min-colors 88) (background dark))
     :background "#e3a2ff" :foreground "black")
    (t :background "magenta" :foreground "black"))
  "Face for modeline indicators with a background."
  :group 'kam-modeline-faces)

(defface kam-modeline-indicator-cyan
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#004060")
    (((class color) (min-colors 88) (background dark))
     :foreground "#30b7cc")
    (t :foreground "cyan"))
  "Face for modeline indicators."
  :group 'kam-modeline-faces)

(defface kam-modeline-indicator-cyan-bg
  '((default :inherit (bold kam-modeline-indicator-button))
    (((class color) (min-colors 88) (background light))
     :background "#006080" :foreground "white")
    (((class color) (min-colors 88) (background dark))
     :background "#40c0e0" :foreground "black")
    (t :background "cyan" :foreground "black"))
  "Face for modeline indicators with a background."
  :group 'kam-modeline-faces)

(defface kam-modeline-indicator-gray
  '((t :inherit shadow))
  "Face for modeline indicators."
  :group 'kam-modeline-faces)

(defface kam-modeline-indicator-gray-bg
  '((default :inherit (bold kam-modeline-indicator-button))
    (((class color) (min-colors 88) (background light))
     :background "#808080" :foreground "white")
    (((class color) (min-colors 88) (background dark))
     :background "#a0a0a0" :foreground "black")
    (t :inverse-video t))
  "Face for modeline indicators with a background."
  :group 'kam-modeline-faces)
#+end_src
*** Creating the helper functions
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-modeline.el") :mkdirp yes :lexical t
(defun kam-modeline--string-truncate-p (str)
  "Return non-nil if the string should be truncated."
  (cond
   ((or (not (stringp str))
        (string-empty-p str)
        (string-blank-p str))
    nil)
   ((and (kam-common-window-narrow-p)
         (> (length str) kam-modeline-string-truncate-length)
         (not (one-window-p :no-minibuffer))))))

(defun kam-modeline--truncate-p ()
  "Return non-nil if the truncation should happen."
  (and (kam-common-window-narrow-p)
       (not (one-window-p :no-minibuffer))))

(defun kam-modeline-string-cut-end (str)
  "Return truncated STR, if appropriate, else return non-truncated STR.
Cut off the end of STR by counding from its start up to `kam-modeline-string-truncate-length'."
  (if (kam-modeline--string-truncate-p str)
      (concat (substring str 0 kam-modeline-string-truncate-length) "...")
    str))

(defun kam-modeline-string-cut-beginning (str)
  "Return truncated STR, if appropriate, else return non-truncated STR.
Cut off the beginning of STR by counting from its end up to `kam-modeline-string-truncate-length'."
  (if (kam-modeline--string-truncate-p str)
      (concat "..." (substring str (- kam-modeline-string-truncate-length)))
    str))

(defun kam-modeline-string-cut-middle (str)
  "Return truncated STR, if appropriate, else return non-truncated STR.
Cut off the middle of STR by counting half of `kam-modeline-string-truncate-length' from both its beginning and end."
  (let ((half (floor kam-modeline-string-truncate-length 2)))
    (if (kam-modeline--string-truncate-p str)
        (concat (substring str 0 half) "..." (substring str (- half)))
      str)))

(defun kam-modeline-string-abbreviate-but-last (str nthlast)
  "Abbreviate STR, keeping NTHLAST words intact.
Also see `kam-modeline-string-abbreviate'."
  (if (kam-modeline--string-truncate-p str)
      (let* ((all-strings (split-string str "[_-]"))
             (nbutlast-strings (nbutlast (copy-sequence all-strings) nthlast))
             (last-strings (nreverse (ntake nthlast (nreverse (copy-sequence all-strings)))))
             (first-component (mapconcat #'kam-common-first-char nbutlast-strings "-"))
             (last-component (mapconcat #'identity last-strings "-")))
        (if (string-empty-p first-component)
            last-component
          (concat first-component "-" last-component)))
    str))

(defun kam-modeline-string-abbreviate (str)
  "Abbreviate STR individual hyphen or underscore separated words.
Also see `kam-modeline-string-abbreviate-but-last'."
  (if (kam-modeline--string-truncate-p str)
      (mapconcat #'kam-modeline--first-char (split-string str "[_-]") "-")
    str))
#+end_src
*** Defining the modeline variables
#+begin_src emacs-lisp :tangle (concat user-emacs-directory "lisp/kam-modeline.el") :mkdirp yes :lexical t
(defvar-local kam-modeline-kbd-macro
    '(:eval
      (when (and (mode-line-window-selected-p) defining-kbd-macro)
        (propertize " Recording " 'face 'kam-modeline-indicator-orange-bg)))
  "Mode line construct displaying `mode-line-defining-kbd-macro'.
Specific to the current windows mode-line.")

(defvar-local kam-modeline-narrow
    '(:eval
      (when (and (mode-line-window-selected-p)
                 (buffer-narrowed-p)
                 (not (derived-mode-p 'Info-mode 'help-mode 'special-mode 'message-mode)))
        (propertize " Narrow " 'face 'kam-modeline-indicator-cyan-bg)))
  "Mode line construct to report the narrowed state of the current buffer.")

(defvar-local kam-modeline-buffer-status
    '(:eval
      (when (file-remote-p default-directory)
        (propertize " @ "
                    'face 'kam-modeline-indicator-red-bg
                    'mouse-face 'mode-line-highlight)))
  "Mode line construct for showing remote file name.")

(defun kam-modeline-buffer-identification-face ()
  "Return approprite face or face list for `kam-modeline-buffer-identification'."
  (when (mode-line-window-selected-p)
    'mode-line-buffer-id))

(defun kam-modeline--buffer-name ()
  "Return `buffer-name', truncating it if necessary.
See `kam-modeline-string-cut-middle'."
  (when-let* ((name (buffer-name)))
    (kam-modeline-string-cut-middle name)))

(defun kam-modeline-buffer-name ()
  "Return buffer name, with read-only indicator if relevant."
  (let ((name (kam-modeline--buffer-name)))
    (if buffer-read-only
        (format " %s" name)
      name)))

(defun kam-modeline-buffer-name-help-echo ()
  "Return `help-echo' value for `kam-modeline-buffer-identification'."
  (concat
   (propertize (buffer-name) 'face 'mode-line-buffer-id)
   "\n"
   (propertize
    (or (buffer-file-name)
        (format "No underlying file.\nDirectory is: %s" default-directory))
    'face 'font-lock-doc-face)))

(defun kam-modeline-buffer-modified ()
  "Return a buffer modified icon if the buffer has been modified."
  (if (buffer-modified-p)
      ""
    ""))

(defvar-local kam-modeline-buffer-modified
    '(:eval
      (propertize (kam-modeline-buffer-modified)
                  'face 'kam-modeline-indicator-gray
                  'mouse-face 'mode-line-highlight
                  'help-echo (kam-modeline-buffer-name-help-echo)))
  "Mode line construct for displaying the status of buffer modification.")

(defvar-local kam-modeline-buffer-identification
    '(:eval
      (propertize (kam-modeline-buffer-name)
                  'face (kam-modeline-buffer-identification-face)
                  'mouse-face 'mode-line-highlight
                  'help-echo (kam-modeline-buffer-name-help-echo)))
  "Mode line construct for identifying the buffers being displayed.")

(defun kam-modeline-major-mode-indicator ()
  "Return the appropriate propertized mode line indicator for the major mode."
  (let ((indicator (cond
                    ((derived-mode-p 'text-mode) "")
                    ((derived-mode-p 'prog-mode) "")
                    ((derived-mode-p 'comint-mode) "")
                    (t ""))))
    (propertize indicator 'face 'shadow)))

(defun kam-modeline-major-mode-name ()
  "Return capitalized `major-mode' without the -mode suffix."
  (capitalize (string-replace "-mode" "" (symbol-name major-mode))))

(defun kam-modeline-major-mode-help-echo ()
  "Return `help-echo' value for `kam-modeline-major-mode'."
  (if-let* ((parent (get major-mode 'derived-mode-parent)))
      (format "Symbol: `%s'. Derived from: `%s'" major-mode parent)
    (format "Symbol: `%s'." major-mode)))

(defvar-local kam-modeline-major-mode
    (list
     '(:eval
       (concat
        (kam-modeline-major-mode-indicator)
        " "
        (propertize
         (kam-modeline-string-abbreviate-but-last
          (kam-modeline-major-mode-name)
          2)
         'mouse-face 'mode-line-highlight
         'help-echo (kam-modeline-major-mode-help-echo)))))
  "Mode line construct for displaying major modes.")

;; (defvar-local kam-modeline-major-mode
;;     '(:eval
;;       (propertize )))

(defvar-local kam-modeline-process
    (list '("" mode-line-process))
  "Mode line construct for the running process indicator.")

(declare-function vc-git--symbolic-ref "vc-git" (file))

(defun kam-modeline--vc-branch-name (file backend)
  "Return capitalized VC branch name for FILE with BACKEND."
  (when-let* ((rev (vc-working-revision file backend))
              (branch (or (vc-git--symbolic-ref file)
                          (substring rev 0 7))))
    (capitalize branch)))

(defun kam-modeline-diffstat (file)
  "Return shortened Git diff numstat for FILE."
  (when-let* ((output (shell-command-to-string (format "git diff --numstat %s"file)))
              (stats (split-string output "[\s\t]" :omit-nulls "[\s\f\t\n\r\v]+"))
              (added (nth 0 stats))
              (deleted (nth 1 stats)))
    (cond
     ((and (equal added "0") (equal deleted "0"))
      "")
     ((and (not (equal added "0")) (equal deleted "0"))
      (propertize (format "+%s" added) 'face 'kam-modeline-indicator-green))
     ((and (equal added "0") (not (equal deleted "0")))
      (propertize (format "-%s" deleted) 'face 'kam-modeline-indicator-red))
     (t
      (concat
       (propertize (format "+%s" added) 'face 'kam-modeline-indicator-green)
       " "
       (propertize (format "-%s" deleted) 'face 'kam-modeline-indicator-red))))))

(declare-function vc-git-working-revision "vc-git" (file))

(defvar kam-modeline-vc-map
  (let ((map (make-sparse-keymap)))
    (define-key map [mode-line down-mouse-1] 'vc-diff)
    (define-key map [mode-line down-mouse-3] 'vc-root-diff)
    map)
  "Keymap used to display a VC indicator.")

(defun kam-modeline--vc-help-echo (file)
  "Return `help-echo' message for FILE tracked by version control."
  (format "Revision: %s\nmouse-1: `vc-diff'\nmouse-3: `vc-root-diff'"
          (vc-git-working-revision file)))

(defun kam-modeline--vc-text (file branch &optional face)
  "Prepare text for Git controlled FILE, given BRANCH.
With optional FACE, use it to propertize BRANCH."
  (concat
   (propertize "" 'face 'shadow)
   " "
   (propertize branch
               'face face
               'mouse-face 'mode-line-highlight
               'help-echo (kam-modeline--vc-help-echo file)
               'local-map kam-modeline-vc-map)
   " "
   (kam-modeline-diffstat file)))

(defun kam-modeline--vc-details (file branch &optional face)
  "Return Git BRANCH details for FILE, truncating it if necessary.
The string is truncated if the width of the window is smaller than `split-width-threshold'."
  (kam-modeline-string-cut-end
   (kam-modeline--vc-text file branch face)))

(defvar kam-modeline--vc-faces
  '((added . vc-locally-added-state)
    (edited . vc-edited-state)
    (removed . vc-removed-state)
    (missing . vc-missing-state)
    (conflict . vc-conflict-state)
    (locked . vc-locked-state)
    (up-to-date . vc-up-to-date-state))
  "VC state faces.")

(defun kam-modeline--vc-get-face (key)
  "Get face from KEY in `kam-modeline--vc-faces'."
  (alist-get key kam-modeline--vc-faces 'up-to-date))

(defun kam-modeline--vc-face (file backend)
  "Return version control state face for FILE with BACKEND."
  (kam-modeline--vc-get-face (vc-state file backend)))

(defvar-local kam-modeline-vc-branch
    '(:eval
      (when-let* (((mode-line-window-selected-p))
                  (file (buffer-file-name))
                  (backend (vc-backend file))
                  ;; ((vc-git-registered file))
                  (branch (kam-modeline--vc-branch-name file backend))
                  (face (kam-modeline--vc-face file backend)))
        (kam-modeline--vc-details file branch face)))
  "Mode line construct to return propertized VC branch.")

(dolist (construct '(kam-modeline-kbd-macro
                     kam-modeline-narrow
                     kam-modeline-buffer-modified
                     kam-modeline-buffer-status
                     kam-modeline-buffer-identification
                     kam-modeline-major-mode
                     kam-modeline-process
                     kam-modeline-vc-branch))
  (put construct 'risky-local-variable t))

(provide 'kam-modeline)
#+end_src
